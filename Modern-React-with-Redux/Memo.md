- ## Tutorial Memo Index

1. 리액트란 무엇인가?
2. Create-React-App에 대해 알아보기
3. 자바스크립트 모듈
4. 함수형 컴포넌트
5. JSX?
6. JSX의 인라인 CSS스타일
7. Class vs ClassName
8. JSX에서 JS 변수 사용하기
9. JSX에서 사용하지 못하는 값
10. 컴포넌트의 3가지 요소
11. faker 라이브러리 사용하기
12. 컴포넌트를 다른 컴포넌트로 넘겨주기
13. 새로운 컴포넌트에서 JSX 가져오기
14. 리액트 props
15. 컴포넌트의 재활용
16. 클래스 컴포넌트
17. 사용자의 위치정보 받는법
18. 함수형 컴포넌트에서 비동기 처리해주기
19. 함수형 컴포넌트에서 클래스 컴포넌트로 전환
20. state의 규칙
21. constructor를 사용한 state의 초기화
22. geolocation 앱의 작동 순서
23. 라이프사이클 사용해보기
24. 왜 라이프사이클을 사용할까?
25. 스타일링 해주기
26. JSX에서 함수를 이용해 값 표기하기
27. 사진 검색 앱 Overview
28. Controlled Element?
29. Axios vs Fetch
30. Async/Await 사용해보기
31. Axios 초기설정하기
32. ref 사용법
33. 콜백과 이미지 로딩
34. 이벤트 핸들러 작성할때의 주의점
35. Youtube API 사용해보기
36. 콜백을 사용해 부모 컴포넌트의 상태 바꿔주기
37. 비디오앱 완성
38. 리덕스에 대해서1
39. 리덕스에 대해서2
40. 리덕스 써보기
41. 리덕스 키노트
42. React-Redux 라이브러리
43. React와 Redux를 이용해 앱 만들기
44. 앱 Overview
45. Provider 사용하기
46. Connect 사용하기
47. mapStateToProps를 사용해서 state 가져오기
48. 중간정리
49. 컴포넌트에서 action creators 불러오기
50. 왜 컴포넌트를 import하고 다시 connect에 넣는지?
51. 함수형 컴포넌트를 이용해 connect 사용해보기
52. 정리하기
53. Redux-Thunk를 이용해 앱 만들어보기
54. 리덕스를 이용해 데이터 불러오기
55. 더미 action creator 연결해주기
56. Axios와 Action creator를 이용해 서버에 데이터 가져오기
57. Action creator에서 비동기 요청 에러 1
58. Action creator에서 비동기 요청 에러 2
59. 리덕스 미들웨어
60. Redux-Thunk의 역할
61. 비동기 action creator 만드는법
62. 리듀서의 규칙 1
63. 리듀서의 규칙 2
64. 상태를 변형시켜도 된다 하지만...
65. 리듀서 업데이트를 위해 안전하게 객체 변형시키는법
66. 비동기 요청을 통해 서버에서 데이터를 가져오는 과정
67. 어떻게 유저 정보를 보여줄것인가?
68. mapStateToProps를 이용해 필요한 정보 가져오기
69. 반복요청 문제 발생
70. memoize를 통한 문제 해결방법 
71. 다른 방법
72. 새로운 action creator를 생성함으로써 문제 해결방법
73. 새로운 action creator에서 유저의 id를 이용해 필요한 정보 가져오기
74. redux-thunk 정리
75. Streaming App intro
76. 앱 만들때의 어려운점
77. 리액트 라우터 소개 
78. 리액트 라우터가 작동법
79. exact 키워드
80. 리액트 라우터에서 a태그를 쓰면 안되는 이유
81. a태그 대신 Link태그 사용하기
82. 여러 타입의 라우터들
83. 앱 구성요소 컴포넌트
84. 헤더 컴포넌트 만들기
85. 에러 : You should not use Link outside a Router occur
86. Email/Password Authentication vs OAuth Authentication
87. OAuth for Servers vs Browser Apps
88. OAuth 설정 단계
89. 구글 API 초기 연동하기 (OAuth 요청보내기)
90. 구글 API에서 데이터 가져오기 (OAuth에 필요한 데이터 가져오기)
91. 가져온 데이터를 이용해 상태 변환시켜주기 
92. listen 메소드를 이용해 상태 변환 후 화면에 렌더링 해주기
93. 리덕스 연결시키기
94. Action creator 만들기
95. 리듀서 만들기
96. 리듀서에서 컴포넌트로
97. 리덕스를 이용해 OAuth 다루기
98. 변수로 action의 타입 설정해주기
99. 유저의 ID를 redux state에 저장하기
100. Redux Dev Tools 설치 및 설정
101. Redux Dev Tools 디버그 세션
102. 리덕스 폼 라이브러리
103. 리덕스 폼 연결하기
104. 폼 만들기 및 에러발생
105. 에러문제 해결 및 폼 렌더링하기
106. 폼 커스터마이징 하기
107. 폼 submisstion 다루기
108. 폼의 유효성 설정해주기
109. 에러 메세지 렌더링하기 
110. touched 프로퍼티를 이용해 메세지 보여주기 & css 설정
111. Streams의 API 설정
112. JSON Server을 이용해 DB 만들기
113. Action creator 만들어주기
114. RESTful api를 이용해 stream 만들기 
115. Stream을 만든 후에 actions를 dispatch하기
116. 필요한 Action creators 만들기
117. 객체를 반환하는 reducer의 장점
118. Key Interpolation
119. Streaming과 관련된 다양한 reducers 만들어주기
120. Lodash 라이브러리의 _omit 사용해 객체 지우기
121. Lodash 라이브러리를 이용해 배열에서 객체 반환하기 
122. 모든 streams 가져오기
123. 모든 Streams 렌더링하기 
124. userId와 action creator 연결시키기
125. 조건에 맞춰 버튼 보여주기 1
126. 조건에 맞춰 버튼 보여주기 2
127. Intentional Navigation vs Programmatic Navigation
128. history 객체 참조하기
129. 커스텀 history 객체 만들기
130. 커스텀 history 객체 사용하기
131. 직접 데이터 수정하기
132. 수정 페이지 만드는 방법
133. 아이디에 따른 수정페이지 설정 방법 1
134. Route Params
135. state와 ownProps를 이용해 원하는 아이디 불러오기
136. 각 컴포넌트의 독립성
137. StreamEdit 컴포넌트에서 stream 데이터 가져오기
138. StreamForm 컴포넌트 만들기
139. StreamCreate 컴포넌트 재구성하기 
140. 초기값 셋팅하기 
141. Lodash를 이용해 필요한 값만 고르기
142. 수정된 내용 제출
143. PUT vs PATCH
144. HTML을 사용해 modal 만들어보기
145. Portal를 사용해 modal을 만드는 이유
146. Portal를 사용해 modal 만들기
147. Modal 숨기기
148. Modal 재활용하기
149. React.Fragment
150. history 객체를 prop으로 내려주기
151. delete 요청에 ID 넣어주기
152. StreamDelete 컴포넌트에서 해당 stream 가져오기
153. 조건적으로 stream의 디테일 보여주기
154. stream 지우기
155. Stream에 링크걸어주기
156. Switch 사용하기 



## 1. Critical Question related to React

- What is React and its purpose?

  - React is a JavaScript library
  - React's ultimate purpose is to show content(HTML) to users and handle user interaction

- Why didn't we use Redux to make the app?

  - React can work by itself
  - But React can also work with a tremendous variety of other libraries , packages, servers and databases.

- What was 'class' thing in React?

  - It is a JS 'class'
  - React _components_ are made using either JS functions or classes.

- What was the HTML looking stuff in React?

  - It is called JSX
  - It looks like HTML and can be placed in JS code. It Determines the content of a React app just like normal HTML

- How did the screen change when a mouse is moved?

  - An event handler
  - Event handlers are used to detect user interaction and respond to it.

- Why did we add two libraries (React and ReactDOM)?

  - React is split into two separate libraries.
  - React knows what a component is and how to make components work together.
  - ReactDOM knows how to take a component and make it show up in the DOM.

## 2. Exploring a Create-React-App Project

- src : Folder where we put all the source code we write.
- public : Folder that stores static files like images.
- node_modules : Folder that contains all of our project dependencies.
- package.json : Records our project dependencies and configures our project.
- package-lock.json : Records the exact version of packages that we install.
- README.md : Instructions on how to use this project.

## 3. JavaScript Module Systems

- import React from 'react'
  - import : we want to get code from some other file or dependency
  - React : The variable we want to assign this import to (It is a convention to name the variable according to the name of library)
  - from : We are about to specify the name of the library or file we are importing from
  - 'react' : The name of the dependency or path to the file we are importing from node_modules

## 4. Displaying Content with Functional Components

- A component is a _Function_ or _Class_ that produces HTML to show the user using JSX and handles feedback from the user using Event Handlers.

## 5. What is JSX?

- It is a special dialect of JS (it is not HTML!)
- Browsers do not understand JSX code. We write JSX then run tools to turn it into normal JS
- Very similar in form and function to HTML with a couple differences.

## 6. Inline Styling with JSX

- JSX vs HTML
  - Adding custom styling to an element uses different syntax.
    - HTML : <div style="background-color:red;"></div>
    - JSX : <div style={{backgroundColor:'red'}}></div>

## 7. Class vs ClassName

- Adding a class to an element uses different syntax.
  - HTML : class
  - JSX : className (to avoid collision of words with class in component)

## 8. Referencing JS Variables in JSX

- JSX can reference JS variables and function call inside of {}.

## 9. Values JSX Can't show

- We are not allowed to take plain JS object and reference it inside of JSX to print it up as 'text'.

## 10. Three Tenets of Components

- Component Nesting
  - A component can be shown inside of another.
- Component Reusability
  - We want to make components that can be easily reused through out application.
- Component Configuration
  - We should be able to configure a component when it is created. When we create different components, we have ability to somehow customize them when they are created.

## 11. Specifying Images in JSX

- We are going to use library called 'faker'.
  - It automatically generates massive amount of realistic fake data.

## 12. Showing Custom Children

- When we pass one component to another as child component, It is going to show up inside of the component on the prop's object and specifically on a property of the prop's object called the children property.

```js
<ApprovalCard>
  <CommentDetail
    author="Sam"
    timeAgo="Today at 4:00PM"
    commentText="Thank you!"
    source={faker.image.avatar()}
  />
</ApprovalCard>
```

## 13. Extracting JSX to New Components

- Steps for creating a reusable and configurable component

  - Identify the JSX that apprears to be duplicated
  - What is the purpose of that block of JSX? Think of a descriptive name for what it does
  - Create a new file to house this new component - it should have the same name as the component
  - Create a new component in the new file, paste the JSX into it
  - Make the new component configurable by using React's 'props' system.

## 14. React's Props System

- Props is a system for passing data from a parent component to a child component.
- Goal is to customize or configure a child component.

## 15. Component Reuse

- Passing children to a component and then showing the children inside of parents component, we can provide as many elements as we wish.
- One key thing that we have to keep in mind is that whenever we want to use the technique, we always have to make sure that we go into the target component (ApprovalCard component) and make sure that we somewhere reference props.children inside of there.

```js
<ApprovalCard>
  <h4>Warning!</h4>
  <div>You sure you want to do this?</div>
</ApprovalCard>
```

## 16. Class-Based Components

- Functional Components
  - Good for simple content
- Class Components
  - Good for just about everything else
- Benefits of Class Components
  - Easier code organiztion
  - Can use 'state' -> Easier to handle user input
  - Understands lifecycle events -> Easier to do things when the app first starts

## 17. Getting a USERS Physical Location

- You can find it in MDN.
- type 'window.navigator.geolocation.getCurrentPosition();' inside of App component.

```js
window.navigator.geolocation.getCurrentPosition(
  position => console.log(position), // you can check your current position here
  err => console.log(err) // in case the user does not allow to share their location
);
```

## 18. Handling Async Operations with Functional Components

- Steps of what happens inside of user's browser
  - JS file loaded by browser
  - App component gets created
  - We call geolocation service (it will take sometime to get the result back from a server)
  - App returns JSX, gets rendered to page as HTML
  - We get result of geolocation
  - Tell the component to rerender itself with this new information

## 19. Refactoring from Frunctional to Class Components

- Rules of Class Components
  - Must be a JavaScript Class
  - Must extend (subclass) React.Component
  - Must define a 'render' method that returns some amount of JSX

## 20. The Rules of State

- Rule of State
  - Only usable with class components.
  - You will confuse props with state.
  - 'State' is a JS object that contains data relevant to a singular component.
  - Updating 'state' on a component causes the component to instantly rerender.
  - _State must be initialized when a component is created._
  - _State can only be updated using the function'setState'_.

## 21. Initializing State Through Constructors

- Constructor
  - constructor function is going to be called any time an instance of the class is created. In other words any time that we create a new instance of the app component and show it on the screen. It is going to be automatically and instantly called before anything else.
- Super

  - The app component is extending or borrowing functionality from the react component base class (React.Component).
    It has a constructor function of its own that goes through some amount of setup our real component for us.
  - When we define a constructor function inside of our App class, we are essentially overriding or replacing the consturctor function that is inside of the reactor component class.
  - But we still want to make sure that all the set up code inside of the React.Component constructor function still gets called.
  - So to make sure that the parents or react components constructor function gets called, we call super with props.
  - In other words, Super is a reference to the parent's constructor function.

## 22. App Lifecycle Walkthrough

- Steps from the first load up to showing result on browser.
  - JS file loaded by browser
  - Instance of App component is created
  - App components 'constructor' function gets called
  - State object is created and assigned to the 'this.state' property
  - We call geolocation service
  - React calls the components render method
  - _App returns JSX, gets rendered to page as HTML_
  - We get result of geolocation!
  - We update our state object with a call to 'this.setState'
  - React sees that we updated the state of a component
  - React calls our 'render' method a seconde time
  - _Render method returns some (updated) JSX_
  - React takes that JSX and updates content on the screen

## 23. Introducing Lifecycle Method

- Component Lifecycle flow
  - constructor
  - render
  - (content visible on screen)
  - componentDidMount
    - If we define a function inside of a class(out of the render method), and define specifically 'componenDidMount()'. It is automatically called only one time when the component first gets rendered on a screen.
  - (Sit and wait for updates in setState...)
  - componentDidUpdate
    - If we define a function inside of a class(out of the render method), and define specifically 'componenDidUpdate()'. It is automatically called anytime when the component gets updated itself.
      (Anytime the component updates, the render method would be called, it will return JSX, it would be shown on the screen, and right after that componentWillUpdate would be called.)
  - (Sit and wait until this component is no longer shown)
  - componentWillUnmount
    - It is usually used if we do want some clean-up after the component.

## 24. Why Lifecycle Methods?

- componentDidMount
  - The method is a perfect location to do some initial data loading for the component.
  - Or kick off some outside process like getting the users current position if you only have to do this one time.
  - According to react-document, do not data loading inside of constructor function even if you can do it. Instead use componentDidMount.
  - Reason is that if you always centralize all of your data loading stuff inside of componentDidMount method, it is going to lead to more clear code.
- componentDidUpdate
  - It gets called everytime that a component is updated in case the state changes or the component gets a new set of props from its parent etc.
  - This would be a good location to do some data loading that needs to be done every single time that a component is updated.
  - A good example is that if we wanted to make some type of network request every single time that user clicks on a button or every single time that they enter some text into an input or every single time that we get some new props from a parent component.
- componentWillUnmount
  - It is used when we remove component from the screen and we need to do some clean-up after it.
  - It would be using frequently when we work with non react libraries such as using Google maps inside of a react application.
- There are other three lifecycles. shouldComponentUpdate, getDerivedStateFromProps, getSnapshotBeforeUpdate. However, these methods are rarely used.

## 25. Adding Some Styling

- When a css file is imported to js file, webpack is going to see that we are importing a css file. It is going to take the contents out of there and then stick it into the index.html file.

## 26. Avoiding Conditionals in render()

- In general, anytime we make a component we always try as much as possible to do not have multiple 'return' statement in render method.
- If we ever have to have conditional logic, we are always going to instead put it into a helper method.

```js
renderContent() {
    if (this.state.errorMessage && !this.state.lat) {
      return <div>Error: {this.state.errorMessage}</div>;
    } else if (!this.state.errorMessage && this.state.lat) {
      return (
        <SeasonDisplay
          lat={this.state.lat}
          errorMessage={this.state.errorMessage}
        />
      );
    } else {
      return <Spinner />;
    }
  }
```

## 27. App Overview

- Stuff to still figure out
  - How do we get feedback from the user? (user-interaction, event)
  - How do we fetch data from some outside API or server?
  - How do we show lists of records?

## 28. More on Controlled Element

- Input working flow
  - User types in input
  - Callback gets invoked
  - We call setState with the new value
  - Component rerenders
  - Input is told what its value is (coming from state) (whatever we assign to the value prop is what the input is going to show)
- The key idea is that we are storing information inside of react components on state property not inside the DOM. (input value indicates 'go look at state to get current value')
- In order words, user types the input, the input know what the text is. And then we call onChange and inform the component about the new input. And then we re-render the component, we set the value of the input with essentially the value that is already in there.
- React application driving and storing all the data not HTML side.

## 29. Axios vs Fetch

- Axios
  - Third party package
- Fetch
  - Function built into modern browsers
  - But fetch is more basic and lower level function to use to fetch data.

## 30. Handling Requests with Async/Await

- Component renders itself one time with no list of images
- onSearchSubmit method called
- Request made to unsplash
- ...wait...
- Request complete
- Set image data on state of App component
- App component re-renders and shows images

## 31. Creating Custom Clients

- Nice thing about axios is that you can kind of set up a pre-configured instance of the axios client that has default properties set for where it is going to make a request to, headers and even params.
- Create a file only for using axios.
- create method is going to create an instance of the axios client with a couple of defaulted properties. In order wors it allows us to create a customized little copy of that is customized just towards making requests to some specific url with headers.

## 32. Accessing the DOM with Refs

- What we are going to do?
  - Let the ImageCard render itself and its image
  - Reach into the DOM and figure out the height of the image
  - Set the image height on state to get the component to rerender
- When re-rendering, assign a 'grid-row-end' to make sure the image takes up the appropriate space When we want to access DOM elements directly using react, we make use of 'ref' system.
- React Refs
  - It gives access to a single DOM element.
  - We create refs in the constructor, assign them to instance variables, then pass to a particular JSX element as props.

```js
 constructor(props) {
    super(props);
    this.imageRef = React.createRef();
  }

  componentDidMount() {
    console.log(this.imageRef.current.clientHeight);
  }

```

- However, 0 will be printed out in console.
- Reason is the instant after we have rendered the image in componentDidMount method, the image itself has not actually loaded. Because a DOM element is going to attempt to make a request to some outside service to actually load up the raw image file. (Reaching out to the url that we are referencing and downloading the image.)
- In order words, the reason of we see 0 for every one of these results is because we are a console.log in these values out before we have even had a chance to load the image up.

## 33. Callbacks on Image Load

- In order to fix this, we are going to reference the 'this.imageRef.current' and add event-listener to it.

```js
componentDidMount() {
    this.imageRef.current.addEventListener("load", this.setSpans);
  }

  setSpans = () => {
    const height = this.imageRef.current.clientHeight;
    const spans = Math.ceil(height / 10);
    this.setState({ spans: spans });
  };
```

## 34. Reminder on Event Handlers

- Do not assign the value property to input tag without onChange property.

## 35. Accessing the Youtube API

- React app is goint to make use of axios library.
- It is going to make a network request over to the YouTube API.
- YouTube API is then going to respond to us with a list of videos to show on the screen.
- The list of videos is going to be an array of objects where every object represents a different videos.
- But first, get the API key at console.developers.google.com

## 36. Deeply Nested Callbacks

- When we want to communicate from a child's component back up to some parent component, we usually make use of a callback.
- Beware of a syntax just function call or arrow function in onClick method.
- reference : https://www.udemy.com/react-redux/learn/v4/t/lecture/12531374?start=0

```js
// this
<div onClick={() => onVideoSelect(video)} className="video-item item">
  <img
    className="ui image"
    src={video.snippet.thumbnails.medium.url}
    key={video.id.videoId}
  />
   <div className="content">
    <div className="header">{video.snippet.title}</div>
  </div>
</div>
// and this works differently
<div onClick={onVideoSelect(video)} className="video-item item">
  <img
    className="ui image"
    src={video.snippet.thumbnails.medium.url}
    key={video.id.videoId}
  />
  <div className="content">
    <div className="header">{video.snippet.title}</div>
  </div>
</div>
```

## 37. Displaying a Video Player

- iframe is like any other HTML tag such as div or a span
- But iframe is going to attempt to make a request to some outside website that the user is currently visiting on the screen.
- Therefore, we are going to create iframe element and tell it to make a request on its own without any Ajax stuff over to some very specific YouTube address.

```js
<div className="ui embed">
  <iframe src={`https://www.youtube.com/emb{video.id.videoId}`} />
</div>
```

## 38. What is Redux?

- State management library
- Makes creating complex application easier
- Not required to create a React app
- Not explicitly designed to work with React

## 39. Redux by Analogy

- How we are going to study redux?
  - Story(analogy) to help you understand Redux
  - Write some code in Codepen with Redux only
  - Work on a React App
  - Understand how to integrate React with Redux
- Redux Cycle (Insurance Company metaphor)
  - Action Creator (Person dropping off the form)
    - It is a function that is going to create or return a plain JS object(action)
  - Action (the form)
    - JS object that created by the creator
    - It's purpose is to describe some change that we want to make to the data inside of our application
    - It has type property and payload property
      - type property
        - type property in action describes some change that we want to make inside of our data
      - payload property
        - It describes some contexts around the change that we want to make
  - Dispatch (form receiver)
    - It is going to take in action and make copies of that object and then pass it off to a bunch of different places inside of an application
  - Reducers (Departments)
    - What dispatch does leads us to reducer.
    - It is a function for taking in an action and some existing amount of data.
    - It is going to process that action and then make some change to the data and then return it so that it can then be centralized in some other location(state).
  - State (Compiled department data)
    - In redux, state property is a central repository of all information that has been created by our reducers.
    - All the information gets consolidated inside the state object so that the react application can very easily reach in to our redux application and get access to all of the data of the application.
    - In that way our react app does not have to go around to each separate reducer.
  - Store
    - It is the assembly of a collection of different reducers and action creators.

## 40. Modeling with Redux

- How to create action creator and action

```js
// People dropping off a form (action creator)
const createPolicy = (name, amount) => {
  return {
    // action
    type: "CREATE_POLICY",
    payload: {
      name,
      amount
    }
  };
};

const createClaim = (name, amountOfMoneyToCollect) => {
  return {
    type: "CREATE_CLAIM",
    payload: {
      name,
      amountOfMoneyToCollect
    }
  };
};

const deletePolicy = name => {
  return {
    type: "DELETE_POLICY",
    payload: {
      name
    }
  };
};
```

- How to create reducers and dispatch data, get data

```js
// Reducers (Departments)
const claimHistory = (oldListOfClaims = [], action) => {
  if (action.type === "CREATE_CLAIM") {
    // we care about this action (Form)
    return [...oldListOfClaims, action.payload];
  }
  // we don't care the action (form!)
  return oldListOfClaims;
};

const policies = (listOfPolicies = [], action) => {
  if (action.type === "CREATE_POLICY") {
    return [...listOfPolicies, action.payload.name];
  } else if (action.type === "DELETE_POLICY") {
    return listOfPolicies.filter(policy => policy !== action.payload.name);
  }

  return listOfPolicies;
};

const accounting = (bagOfMoney = 100, action) => {
  if (action.type === "CREATE_CLAIM") {
    return bagOfMoney - action.payload.amountOfMoneyToCollect;
  } else if (action.type === "CREATE_POLICY") {
    return bagOfMoney + action.payload.amountOfMoneyToCollect;
  }
  return bagOfMoney;
};

const { createStore, combineReducers } = Redux;

const ourDepartments = combineReducers({
  // Each of these variables are the names of our different reducers
  accounting,
  claimHistory,
  policies
});

// store object represents entire redux application
// It contains references to all of our different reducers and to all of our state produced by those reducers
const store = createStore(ourDepartments);

// we want to pass the dispatch function an action when we sent it in action
store.dispatch(createPolicy("Alex", 20));
store.dispatch(createPolicy("Jim", 30));
store.dispatch(createPolicy("Max", 40)); // total 190

store.dispatch(createPolicy("Max", 120)); // total 70 left
store.dispatch(createPolicy("Max", 50)); // total 20 left

store.dispatch(deletePolicy("Bob"));

// It is a function that is going to essentially get our entire assembled repository of data
store.getStaste();
```

- The goal of reducer is to take some existing data, some action and then modify and return that existing data based upon the contents of an action.

## 41. Important Redux Notes

- Action Creator -> Action -> dispatch -> Reducers -> State -> Wait until we need to update state again
- Anytime we want to change the state or the data of an application, we are going to call an action creator.
- Calling an action creator is going to produce an action object. It describes exactly how we want to change data inside of application that action object gets fed to dispatch function.
- This is going to make copies action object and feed those copies to each of different reducers.
- Reducers run and they are going to process those actions modify their data and then eventually return some new data.
- The data gets returned gets form into some new state object.
- Then we wait until we need to somehow updates our state again at some point in the future.
- Each object that store calls such as store.dispatch(), store.getState() is separate execution of entire redux cycle. So at any point in time along the application, we can take this store obejct and pull our state out of it and read the current state where the current data for the application.
- We can only modify the state object(assembly of all the data) through the use of the dispatch function and the action creator and action. There is no way that we can somehow manually reach into the store and modify the state.

## 42. React-Redux

- React-Redux is thrid library that we are going to use to make sure that react in redux can talk to each other.
- It has a bunch of helper functions inside of it to get redux to work nicely with react.

## 43. Song app Overview

- This time we are going to use react with redux to build the app
- We are going to create two reducers(Song list reducer, Selected song reducer) and one action creators(select song) into redux side application.
- Using action creator, we are going to change the state.
- If you want to change what the currently selected song is we are gong to call the action creator(select song). That will dispatch an action and tell selected song reducer to update its data and reflect the new current present picked song.

## 44. How React-Redux Works?

- We are going to create two new components (Provider, Connect) using react-redux.
- create store that contains all the reducers and pass it as prop in Provider components.(Provider component is going to be rendered at the top of application hierarchy even above the App component. So technically we are going to show the App component inside of Provider component).
- Then Provider component is going to have eternal reference to the store. (Provider is literally providing information to all of the different components inside of the application.)
- After that we are going to find every component inside of the application that needs to somehow access the data that is stored inside of the Store (like SongList component).
- Therfore we are going to create Connect component right above(in the hierarchy) the SongList component. So SongList component is going to be wrapped with Connect component.
- Connect component is very special. Because it communicates with the Provider component not through props but a completely different system called context system.
- (context system allows any parent component to communicate directly with any child component even if there are other components in between them.)
- So at some point, when we put the Connect component in there, we are going to configure the Connect component and tell it when it gets rendered on the screen(when it renders the SongList as a child), it needs to reach back up Provider component and tell it that needs to get the list of songs that are contained within the store.
- Connect component in turn, take the list of songs and pass it as a prop down into our SongList component.
- We call action creator, we take the action that gets returned and we send it into the store.dispatch function.
- _Entire flow is essentially we are going to create the Provider component and pass it as a reference to redux store then anytime we have a component that needs to interact with the redux store(SongList component in this case), it is going to be wrapped up with Connect component._
- _Then configure the Connect component by telling it what different pieces of states we want out of our store and what different action creators we want to have wired up as well_
- _After that Connect component is going to makes sure that all the data(both the state and the action creators) shows up inside of our component as props._

## 45. Wiring Up the Provider

- When we make use of the react-redux library, we don't usually mess around with the store directly.
- Instead we pass it off to the provider and it is essentially takes care of everything from there.

```js
ReactDOM.render(
  <Provider store={createStore(reducers)}>
    <App />
  </Provider>,
  document.querySelector("#root")
);
```

## 46. The Connect Function

- We are able to connect to Provider component using Connect function

```js
class SongList extends React.Component {
  render() {
    return <div>SongList</div>;
  }
}

// connect function is called twice. (function inside of another function)
export default connect()(SongList);
```

## 47. Configuring Connect with MapStateToProps

- We are going to specifically tell the connect function that we want to get a list of songs out of the redux store from the Provider.
- So anytime that our list of songs and inside of our store changes, Provider is going to automatically notify the Connect component.
- Then it is going to pass our list of songs down to our SongList component.
- After defining mapStateToProps function and then going to take it and pass it as the first argument to the Connect function.
- state argument in mapStateToProps is essentially going to be our entire list of songs from the song list reducer.
- We can figure Connect component by passing it a function.
- The object returned from mapStateToProps function is going to show up as props inside of the component

```js
class SongList extends React.Component {
  render() {
    // this.props === {songs: state.songs}
    return <div>SongList</div>;
  }
}

const mapStateToProps = state => {
  return { songs: state.songs };
};

export default connect(mapStateToProps)(SongList);
```

## 48. 정리하자면...

1.  reducer 폴더안에서 index.js를 생성. index.js는 안에 있는 reducer 함수들을 combinReducers라는 객체로 묶어 export한다.
2.  메인 index.js 파일은 redux의 Provider, createStore 그리고 reducer 폴더에서 export한 index.js를 reducers라는 이름으로 import한다.
3.  App 컴포넌트가 SongList 컴포넌트를 반환하고 있으므로 App 컴포넌트를 Provider 컴포넌트로 감싸고 props 형식으로 createStore(reducers)를 store라는 이름으로 내려준다.
4.  Provider와 연결하기 위해 SongList 컴포넌트에 connect()()를 만들어준 뒤 두번째 인수에 SongList 컴포넌트를 입력
5.  mapStateToProps 함수를 만들어 state를 인수로 받았는데 이 state는 reducer에 담긴 모든 정보를 포함하고 있다. state에서 원하는 정보를 return한 뒤 connect의 첫번째 인수로 mapStateToProps를 넣는다. 참고로 반환된 값(객체)는 내려받은 값이기 때문에 props와 같다고 할 수 있다.

## 49. Calling Action Creators from Components

- Connect component is going to be used not only to get data out of our store but it can also be used to get action creators correctly into the SongList.
- And put it into as a second argument of Connect function in the form of object.

```js
export default connect(
  // these are all props
  mapStateToProps,
  { selectSong }
)(SongList);
```

- Connect function is going to take selectSong action creator and pass it into the component as a prop inside of event-handler.
- When selectSong is called, it is going to automatically take the action that gets returned and send it it to redux's dispatch function.
- _Importantly, you must dispatch an action to update the store. You cannot directly modify props by doing this.props.something = 'some new value". What Stephen is saying in this lecture is that when we update our Redux store thru a dispatched action, mapStateToProps will automatically rerun and return to us this new state object._

## 50. Redux is Not Magic

- Redux does not automatically detect action creators being called.
- Redux does not automatically detect a function returning an object that is an action.
- selectSong is not a normal JS function. It is an action. However, redux does not recognize selectSong as what it is automatically.
- If we want to make sure that an action eventually makes its way over to reducers, we have to take the action that gets returned and we have to pass it into the dispatch function.
- If we just use function call with arguments none of these function calls are going to update the store.
- Function call returns the actions but never got sent into redux.
- When we pass action creators into the connect function, it does a special operation on the functions inside of the object.
- connect functions include inside the object, it wraps them up in another JS function. When we call the new JS function, _the connect function is going to automatically calls action creator, it is going to automatically take the action that gets returned and call dispatch function for us._
- So anytime we want to call an action creator from a component, we are always going to pass it into connect function.

## 51. Functional Components with Connect

- SongDetail component has no functionality tied to it such as event handler that causes a change to a redux state. So we do not need to wire up any action creators to our songDetail component.

## 52. Conditional Rendering and Wrappin up

- In integrating react and redux, we are going to create our components as we usually do.
- We are going to then select some very specific components inside of our application that need to receive some information or need to make changes to the state
- if we need to make changes to the state or receive information, we are going to import that connect function or component and then at the bottom of the file we can define a mapStateToProps function.
- And then pass that function as the first argument in connect function, actual component that we care about as a second function call.

## 53. Initial App Setup

- Redux-Thunk
  - Middleware is a function that are going to slightly change the behavior of the redux store and help us make requests in a redux application.
  - Middleware applies to the library 'redux'
  - Redux-Thunk is a middleware that is going to help us make network requests from the redux side of app.

## 54. How to Fetch Data in a Redux App

- General Data Loading with Redux
  - (This is a common pattern)
  1. Component gets rendered onto the screen
  2. Component's 'componentDidMount' lifecycle method gets called
  3. We call action creator from 'componentDidMount'
  - (From 1 to 3, Components are generally responsible for fetching data they need by calling an action creator)
  4. Action creator runs code to make an API request
  5. API responds with data
  6. Action creator returns an 'action' with the fetched data on the 'payload' property
  - (From 4 to 6, Action creators are responsible for making API requests and we are going to use Redux-Thunk)
  7. Some reducer sees the action, returns the data off the 'payload'
  8. Because we generated some new state obejct, redux/react-redux cause our React app to be rendered
  - (From 7 to 8, We get fetched data into a component by generating new state in our redux store, then getting that into our component through mapStateToProps)

## 55. Wiring Up an Action Creator

- Set up the dummy action creator and imports it in PostList.js
- And put the creator into connect function and call it using props in componenDidMount method. (step from 1 to 3)

```js
class PostList extends React.Component {
  componentDidMount() {
    this.props.fetchPosts();
  }
  render() {
    return <div>Post List</div>;
  }
}

export default connect(
  null,
  { fetchPosts }
)(PostList);
```

## 56. Making a Request From an Action Creator

```js
export const fetchPosts = async () => {
  const res = await jsonPlaceholder.get("/posts");
  return {
    type: "FETCH-POSTS",
    payload: res
  };
};
```

- The code seems right but that is a bad approach because we are specifically breaking the rules of redux and action creator.
- When you see the console. You got an arror saying 'Actions must be plain objects. Use custom middleware for async actions.'

## 57. Understanding Async Action Creators

- Let's find out the problem
- You might be asked for interview question.
- What is wrong with 'fetchPosts'?

  - When you go back to action creator file and look at the function, it looks like the function returning a plain JS object. In fact, it is not!!
  - Since the code is transfiled by babel to ES5 code, when babel transfiles async/await function which are functions that do not exist in ES5, those two become a huge chunk of syntax that using switch method and returns request object. That is why the action creator is not working as expected.

  ```js
  export const fetchPosts = async () => {
    // BAD APPROACH!!
    const res = await jsonPlaceholder.get("/posts");
    return {
      type: "FETCH-POSTS",
      payload: res
    };
  };

  // Above code is transfiled by babel to ES5 like below code

  export const fetchPosts = async() => {
    case 0:
    // request object is returned not plain object
      return jsonPlaceholder.get('/posts)
    case 1:
      return { type: 'FETCH_POSTS', payload: response};
  }
  ```

## 58. More on Async Action Creators

- We might think we can use promise instead async and await?
- If we do that by the time our action gets to a reducer, we will not have fetched our data!
- When the data flows from action creator to reducers, all of those steps are going to be executed in a fraction of a fraction of a second.
- But that causes an issue with the fact that we are making an asynchronous requests.
- When action creator called, we are going to make the request over to Typicode API and that request take some unknown amount of time to eventaully get a response back from that API.
- So by the time we finally get a response from the API, our action has long since been processed by our reducers.
- The reducers have already ran and they have looked inside that promise object and thinks 'the request is not completed and there is nothing that we can do inside of the reudcers to somehow delay them from running.'
- So
  ```js
  return {
    type: "FETCH-POSTS",
    payload: promise
  };
  ```
  this alternative syntax, it gets sent off to the reducers but all happened so quickly that it happens and completes itself way before ever get any data back from our API right below.

```js
const res = await jsonPlaceholder.get("/posts");
```

- In order words, even if we use this alternate syntax without the async/awaits, we would still run into an issue where we could not get access to our data.

## 59. Middlewares in Redux

- Synchronous action creator
  - It immediately retunrs an action object with all the relevant data attached that object and it is ready to be processed by a reducers.
  - Instantly returns an action with data ready to go.
- Asynchronous action creator
  - Takes some amount of time for it to get its data ready to go.
  - It is one that is going to require a little bit of time before it is ready to eventually dispatch an action.
  - Anytime that you have an action creator that makes a network request, it is always going to qualify as an async action creator.
  - If you want to have asynchonous action creator inside of a redux application, you have to install something called a middleware.
  - That is going to allow you to deal with these asynchronous action creators.
- Action that created by action creator goes to dispatch and be sent to middleware not reducers.
- We can have as many or as few middleware as we want.
- It is a function that gets called with every action we dispatch.
- It has the ability to _STOP, MODIFY_, or otherwise mess around with actions.
  - Simple example would be to create a middleware that simply console.log every action that you dispatch.
- Tons of open source middleware exist.
- Most popular use of middleware is for dealing with async actions.
- We are going to use a middleware called 'Redux-Thunk' to solve our async issues.

## 60. Behind the Scenes of Redux-Thunk

- What Redux-Thunk does?
  - Redux-Thunk is all purpose middleware that allows us to deal with asynchronous action creators but it also allows us to do many other things as well.
  - Noraml rules in vanila redux
    - Action creators must return action obejcts
    - Action must have a 'type' property
    - Actions can optionally have a 'payload'
  - Rules with Redux-Thunk
    - Action creators can return action objects
      (or)
    - Action creators can return functions!
    - (if you return a function, redux-thunk is going to automatically call that function for you)
    - If an action object gets returned, it must have a 'type'.
    - If an action object gets returned, it can optionally have a 'payload'.
- Redux-Thnk flow

  - When redux-thunk meets plain JS object, redux-thunk sends it to reducers
  - However, when redux-thunk meets a function, it works differently.
  - Redux-thunk invokes the function and it passes into the dispatch and getState functions as arguments.

  ```js
  export const fetchPosts = () => {
    return async (dispatch, getState) => {
      const res = await jsonPlaceholder.get("/posts");

      dispatch({ type: "FETCH_POSTS", payload: res.data });
    };
  };
  ```

  - We can pass actions into the dispatch function, those actions will be sent through all of our different middlewares and eventually forwarding it off to the reducers. In order words, dispatch funtion has unlimited power to initiate changes to the data on the redux side of app.
  - getState can be called on a redux store and that will return all of the data inside of it.
  - Through dispatch, we can change any data we want and getState, we can read or access any data that we want.
  - We wait for our requests to finish. In order words, we are going to wait to return or dispatch any action until we eventually get a response from our Typicode API.
  - Once we eventually get the response, _we are then going to use the dispatch function to manually dispatch an action at some point of time in the future._
  - After that we get a new action in form of a plain object or a function but mostly object. (when function gets returned, the flow goes again.)

## 61. Shortened Syntax with Redux-Thunk (how to create an asynchronous action creators)

- To wire up redux-thunk, import applyMiddleware from redux and thunk from redux-thunk in root index.js file.

  ```js
  import { createStore, applyMiddleware } from "redux";
  import thunk from "redux-thunk";

  const store = createStore(reducer, applyMiddleware(thunk));
  ReactDOM.render(
    <Provider store={store}>
      <App />
    </Provider>,
    document.querySelector("#root")
  );
  ```

- When we are making use of redux-thunk, we are not going to return any actions from the inner function anymore. (but you can make another action creator after action creator function.)
- Inside of the inner function, we do not need to return in action.
- If we are returning a function, if we ever want to dispatch an action, we will instead call the dispatch function manually with the action that we are trying to dispatch.
- Instead, call dispatch and pass in my action obejct.
- In redux-thunk, we can use async/await. Because once we have redux-thunk, the async/await syntax is only going to modify the return values of inner function. (remember that if we use async/await in a synchronous action creator, it causes us return a request object not an action )

```js
export const fetchPosts = () => {
  return async (dispatch, getState) => {
    const res = await jsonPlaceholder.get("/posts");

    dispatch({ type: "FETCH_POST", payload: res });
  };
};
```

## 62. Rules of Reducers

- We are going to create a separate file for each reducer.
- The idea is that as we start to work on larger projects with many reducers, puttem all inside of one file is probably not going to scale too well.
- We are going to create another component called postReducer. It is responsible for watching for actions with type 'FETCH_POST' and anytime it sees that it is going to pull off the res that in all the data inside of it and add it into some array.
- Therefore we are going to eventually have a list of sorts with all of different posts that have been fetched from our API.

## 63. Return Values from Reducers

- Rules of Reducers
  - It must return any value besides of 'undefined'.
  - It produces 'state' or data to be used inside of you app using only previous state and the action (reducers are pure).
    - The first time the reducer gets called during that initialization process, it is going to receive two arguments.
    - The first argument is going to have a value of 'undefined'.
    - And then the second argument will be some action obejct.
    - The reducer takes these two arguments and returns some inital some state value.
    - But in many cases, we will defaulted to be the value of first argument as an empty array or empty string etc.
  - It must not return reach out of itsef(or function) to decide what value to return (reducers are pure).
    - Anytime that we call a reducer with an action and previous state value, reducer is not supposed to reach out of the function. In order words, reducers are not supposed to make an API request or try to read some file off a hard-drive or reach into DOM and try to pull some value out of a div or a label or input etc.
    - The only thing that we are going to return is some computation done on the two arguments.
  ```js
  // BAD!
  export default () => {
  return document.querySelector('input)
  };
  // GOOD!
  export default (prevState, action) => {
  return prevState + action // not literally thou
  };
  ```
  - It must not mutate its input 'state' argument.
  ```js
  export default (prevState, action) => {
    // BAD!
    state[0] = "Sam";
    state.pop();
    state.push();
    state.name = "Mike";
    state.age = 30;
  };
  ```
  - If you have a reducer that is always returning a number or a string, you do not need to worry about the mutataion rule. Because those values are immutable.
  - You only have to worry about mutation when you are working with an array or an object.

## 64. A Misleading Rule

- But the rule 'It must not mutate its input 'state' argument.' is extremely misleading. Possibly even false!
- Here is the truth
  _- YOU CAN MUTATE IT ALL DAY AND NOT SEE ANY ERRORS!_
  - However, there is one tiny little corner case in which mutating the state argument is going to land you in trouble.
  - To be honest, it is a lot easier to tell beginners to just not mutate the state argument than to tell them about this corner case and help them to understand.
  - The reason we say 'It must not mutate its input 'state' argument.' is that if you accidentally return the same value (returning prevState) that is pumped into your reducer, redux is going to say 'no difference. Here is the same object or array in memory.' And so we have done absolutely no updates to any data inside of an application, and the react app does not need to be rendered itself. In order words, you will never see any updated content appear on the screen.

## 65. Safe State Updates in Reducers

- (in object, order goes from right to left)
- {...state, name: 'Sam'} instead state.name = 'Sam'
- {...state, age: 30} instead state.age = 30
- {state, age: undefined} instead delete state.name (or you can use lodash library)

## 66. Dispatching Correct Values

- Why do we have two result for one console.log?
  - When the application first loads up inside of the browser, all of our reducers run one initial time.
  - So the instant the application loads up inside the browser, the postReducer runs with an action of some initialization type.
  - Whatever it is, it is not going to match the case 'FETCH_POSTS'. So, we are going to return default state value of an empty array.
  - Therefore, the application first boots up, we are going to have a state object that has a 'FETCH_POSTS' property and the property is going to contain the empty array.
  - After all of the reducers run, the react side of application is going to be rendered one time on the screen.
  - So the PostList component is going to be displayed on the screen one time.
  - During that initial one time, we are going to have the render method called and that is going to invoke the console.log empty array.
  - Immediately after the PostList component shows up on the screen, the _componentDidMount lifecycle_ method will be called and then we go through the entire process of running off to the API and fetching some data.
  - After we get some data back and dispatch the action to reducer, the reducer sees the action has a type of 'FETCH_POSTS', it returns whatever value is inside of the action.payload property.
  - Redux sees that we have not returned the same object in memory the second time the reducer ran. Instead we return a brand new value (action.payload).
  - So the PostList component is going to be rendered to the screen a second time. Also mapStateToProps is going to be called a second time, we are now going to get the new value of state.post and new props.posts property is going to show up inside of the component. The render method gets called again and we see the second result in console.log.
  - (action -> postReducer -> default value -> PostList component rendered -> componentDidMount in PostList component -> fetching data -> action -> reducer -> value in action.payload property -> Redux finds not the same value before -> PostList component -> mapStateToProps -> get a new value from state -> render method gets called -> second result shows up)

## 67. Displaying Users (Getting user information)

- How to get user information?
  - Fetch Posts
  - Show posts in PostList
  - Each element in PostList shows UserHeader component
  - UserHeader is given ID of user to show
  - Each UserHeader attempts to fetch its user
  - Fetch User
  - Show users in each UserHeader

## 68. Extracting Logic to MapStateToProps

- UserHeader component gets access to the user ID and it also gets access to the entire list of users.
- However the UserHeader component is not really well-suited to take the entire array of users. Because the purpose of the component is to show one singular user on the screen. But we are giving it way more data than it ever needs.
- It would be a lot better if we could figure out some way to pass it just the user that it cares about.
- In UserHeader component, mapStateToProps function seems just like a little bit unnecessary. Everytime we want to pull some data out of a component, we have to define this really repetitive function.
- But there is another way that would have been really nice to pull data out of the redux store.
- So essentially rather than finding the appropriate user inside of the component, we want to find it inside of mapStateToProps.
- We can refers props of the component using 'ownProps' object as a second argument of mapStateToProps function.
  ```js
  const mapStatetoProps = (state, ownProps) => {
    return {
      user: state.users.find(user => user.id === ownProps.userId)
    };
  };
  ```

## 69. That's the Issue! (overfetching users)

- When you see the network tab in developer tool, you will find out that the application requets for userId number 10 times in a row.
- Everytime that a UserHeader component is rendered on the screen, componentDidMount is called and fetch user with particular userId.
- So essentially becasue we are rendering out a hundred instances of UserHeader, the action creator gets called a hundred different times even though we are fetching some very very repetitive data.

## 70. One Time Memoization

- In order to repetitive data request, we use memoize library.
- Using \_.memoize, create new function.
- Do not use \_.memoize inside of fetchUser function. It won't work
- After create a new memoizefunction, connects it with fetchUser function

  ```js
  export const fetchUser = id => {
    return (dispatch, getState) => {
      _fetchUser(id, dispatch);
    };
  };

  // private function
  const _fetchUser = _.memoize(async (id, dispatch) => {
    const res = await jsonPlaceholder.get(`/users/${id}`);

    dispatch({ type: "FETCH_USER", payload: res.data });
  });
  ```

- However if you refetch the user some reason like if you have made a change to a user or if you know that the user data has been updated on your API etc.
- Unfortunately you would not be able to do it again using this action creator. So if you want to do it then you have to create another action creator that has the same logic except memoiztion step.
- So this is not the best solution.

## 71. Alternate Overfetching Solution

- We are going to create new action creator called 'fetchPostsAndUsers()'.
  - Logic that we are going to execute inside of the component
    - Call 'fetchPosts'
    - Get list of posts
    - Find all unique userId's from list of posts
    - Iterate over unique userId's
    - Call 'fetchUser' with each userId
  - fetchPostsAndUsers action creator is not going to have some logic inside of it to make a network request over to our API.

## 72. Action Creators in Action Creators.

- Create new action creator 'fetchPostsAndUsers'
- Inside of there, call other action creators
- However if we just call action creators inside of the new action creator, it is not going to be dispatched to reducers.
- So when we call action creators inside of the new action creator, we have to pass the result of calling those into the dispatch function.
- When action creator inside of fetachPostsAndUsers is called, redux-thunk is going to see the inner function of the action creator and invoke it and pass in dispatch as the first argument. So then the inner function is going to make a request over to API, get the list of posts and then it is going to dispatch its own action internally and start that entire process of updating the reducer.
- SO WHENVER WE CALL AN ACTION CREATOR FROM INSIDE OF ANOTHER ACTION CREATOR, WE NEED TO MAKE SURE THAT WE DISPATCH THE RESULT OF CALLING THE ACTION CREATOR.

  ```js
  export const fetchPostsAndUsers = () => {
    return async dispatch => {
      dispatch(fetchPosts());
    };
  };

  export const fetchPosts = () => {
    return async (dispatch, getState) => {
      const res = await jsonPlaceholder.get("/posts");

      dispatch({ type: "FETCH_POSTS", payload: res.data });
    };
  };
  ```

- But whenver we call fetchPosts that is going to initiate an asynchronous request over to the API.
- We need to somehow make sure that we do not attempt to get the our list of posts that have been fetched until fetchPosts action creator has completed and has fetched all the appropriate data.
- So we are going to put 'await' keyword in front of dispatch method in order to make sure that when we dispatch that action creator and the inner function eventually gets called, await keyword is essentially make sure that we wait for the API request to be completed before we move on and do things inside of new action creator.

```js
export const fetchPostsAndUsers = () => {
  return async dispatch => {
    await dispatch(fetchPosts());
  };
};
```

## 73. Finding Unique User Ids

- It is easy to get the state of post. We can use getState object to do it.
  ```js
   return async (dispatch, getState) => {
    await dispatch(fetchPosts());
    console.log(getState().posts);
  };
  ```
- After we get the data from getState().posts, we need to iterate through it list of posts find a unique user IDs and then fetch user for each one. 
- To do that, we can use Lodash library, memoization step.
- lodash is working with the list of posts and pulling out the userIds and finding just the unique ones pretty easy and straightforward.
- We use lodash version of map to get all userId
  ```js
  _.map(getState().posts, "userId");
  ```
- And use _.uniq to return an array with the unique user ids
  ```js
  const userIds = _.uniq(_.map(getState().posts, "userId"));
  console.log(userIds); // [1,2,3,4,5,6,7,8,9,10]
  ```
- Last thing to do is iterate over the variable userIds which contains the array of user ids for every id, we need to call fetchUser action creator.
  ```js
   userIds.forEach(id => dispatch(fetchUser(id)));
  ```
- No await keyword this time. Because we do not care at all about waiting for eash user to be fetched inside a fetchPosts users. (이미 필요한 데이터는 다 있으니까 기다릴 필요가 없음)
- And remove componentDidMount lifecycle from UserHeader component because the lifecycle method keeps attempting to fetch the data.  

## 74. App Wrapup

- Inside of a root index file, we had imported redux-thunk and then we wired it up to a store through the use of applyMiddleware. 
- applyMiddleware is a function from redux library itself, we passed it into second argument of the createStore call when we apply the middleware. 
- When we apply the middleware of redux-thunk, anytime we dispatch an action, the action will be first sent to redux-thunk and after redux-thunk, the action will be sent off to all of different reducers.
- When we wire up redux-thunk, it changed the rules of our action creators. 
- Which means inside of our action creator, we no longer had to create action creators that always returned in action object.
- Instead with redux-thunk, we could also optionally return a function.  
- If we return a function, it would be automatically called with the dispatch and getState arguments and that essentially gave us total control over changing or getting information out of our redux store. 
- Anytime that we expect to make an API request from an actual creator, we are always going to make use of something like redux-thunk. 
- When we return a function from our action creators, we use interesting syntax righ here:
```js
  export const fetchPosts = () => {
  return async (dispatch, getState) => {
    const res = await jsonPlaceholder.get("/posts");

    dispatch({ type: "FETCH_POSTS", payload: res.data });
  };
};
```
- The syntax right here is we have a function that returns a function (outer function => inner function). And it is very common syntax in redux-thunk.
- Alternate solution to solving overfetching issue, we created a new action creator that somehow called other action creators and made sure that we still dispatch the result of calling those action creators. 
  
```js
  export const fetchPostsAndUsers = () => {
      return async (dispatch, getState) => {
        await dispatch(fetchPosts());
        const userIds = _.uniq(_.map(getState().posts, "userId"));
        userIds.forEach(id => dispatch(fetchUser(id)));
      };
    };
```

- In reducer, in frist argument is what I refer to as states and whatever was returned from this reducer or the last time that it ran. 
- So we run this reducer over and over again, whenever we return shows up as the first argument. 
- We also learned that we usually make use of switch statment syntax inside of reducer. And it is very common pattern.
```js
  export default (state = [], action) => {
  switch (action.type) {
    case "FETCH_POSTS":
      return action.payload;
    default:
      return state;
  }
};
```
- *And remember that anytime that we return some data from a reducer, we always have to return a new array or a new object or a different valued string or a different value number, if we expect redux to realize that we made a change to the data inside of our application.*
- If we ever just return the exact same object or array, redux has that very simple comparison where it just checks to see if that is the same object or array in memory.
- And if it is, redux says 'oh no data has changed' and it does not update the rest of your application and tell the react side of the app to actually re-render itself and pull down new state and show some new content on the screen.

## 75. Streaming App Outline

- We are going to have our react application running inside the user's browser.
- We are going to have a small API server that essentially lists out all streams or channels that video can watch.
- the API is going to record what streams or channels exist
- And we are going to have RTMP(Real Time Messaging Protocol) Server that is actually responsible for hadling the video streams itself. 
- RTMP server is very straightforward.

 ## 76. App Challenges

- Need to be able to navigate around to separate pages in our app 
- Need to allow user to login/logout
- Need to handle forms in Redux
- Need to master *CRUD(Create Read Update Destroy)* operations in React/Redux 
- Errors will likely occur! Need good error handling 

## 77. Intoroducing React Router

- React Router family
  - React Rounter
    - Core navigation library 
    - We do not install this manually
    - It is a core library of everything inside the react-router general project
    - It decides how to work with react, how to change content out depending upon some different rules and some other low level logic.
  - React Router Dom
    - Navigation for dom-based apps
    - To get an actual implementation of react-router that works inside of specifically the browser.
    - Anytime that you want to use react router on a project to handle navigation, you are always going to installing react router dom, not react router.
  - React Router Native
    - Navigation for React Native apps
  - React Router Redux
    - Bindings between Redux and React-Router (not necessary)
    - It is a library that is very similar to react-redux library. 
    - It is essentially a compatibility layer to get react router and redux to play along with each other. 

## 78. How React Router works?

- React router does not care that we went to a domain of localhost or we were at port 3000.
- Instead react router only cares about all the characters that are listed after the domain definition and the port definition. 
- So localhost:3000 is interpreted as being localhost:3000/
- If we go to localhost:3000/pageone, react router only cares about everything after the port and the domain. So react router would only care about /pageone. 
- When we created the application and loaded up inside the browser, we created an instance of the BrowserRouter component. 
- BrowserRouter component internally creates an object of its own called history object.
- This object is going to look at the inside of the address bar.
- It is going to extract just that portion of the url that react router curioust about (just everything after domain name and the port).
- History object is then going to communicate the path over to BrowserRouter and then BrowserRouter is then going to communicate that path down to route components. 
- The route components are going to decide either to show themselves or hide themselves depending upon the path inside of the url that the user is visiting, and the path property that it was passed when it was created. 

## 79. How Paths Get Matched

- Inside of react router application, we can very easily have multiple route components that match a given url and all show themselves to the user. 
- So by deeply nesting routes, we can customize how some part of our app looks depending upon the url 
- And we do not have to pass down some deep configuration through redux or props or something like that to configure how a very deeply nested child component renders itself.
- 'exact' keyword.
```js
<Route path="/" exact component={PageOne} />
```
  - A single route or single url or single path can be matched by different routes inside of application. 
  - When you add on a prop name of exact, it causes react router to change the rule that it uses for matching the path slightly. 
  - It essentially changes to extracted path equal the string path (extractedPth === path).
  - It only modifies the route that you add it to. 

## 80. How to Not Navigate with React Router

- Bad Navigation
  - You add an 'a tag' to your application with href='/pagetwo' and click it
  - Your browser makes a request to localhost:3000/pagetwo
  - Development server responds with index.html file
  - *Browser receives index.html file, dumps old HTML file it was showing (including all of your react/redux state data!)*
    - If you put anchor tags inside of your app and then you click on one, you are making a brand new request to some outside server that is going to return a brand new HTML document and then show it on the screen.
    - During the process, the normal operation of the browser is to dump all variables in memory which means all JS data gets entirely dumped. 
    - So that means that in the context of your react redux application, any data that you had loaded up like any API requests or user had typed in anything whatsoever is going to be 100% wiped. 
    - Therefore, you would have to refetched all the data at second time or have user typed all the data in. 
    - (You can check in developer console, network tab)
  - index.html file lists our JS files in script>tags 
  - browser downloads and executes these scripts
  - Our app starts up.

## 81. Navigating with React Router

- Instead of using href and 'a tag', use 'Link tag'.
```js
<Link to="/pagetwo">Navigate to PageTwo</Link>
```
- Using inspector, when you click 'Link tag', what actually showed up in Element console is 'a tag'.
- And also user does not get any additional requests being made for any html document.
- So when you use the 'Link tag', you are still showing an 'a tag' on the screen.
- What we want to do with 'Link tag'.
  - User wants to navigate to another page in our app
  - User clicks a 'Link' tag
  - *React router prevents the browser from navigating to the new page and fetching new index.html file!*
  - URL still changes
  - 'History' object sees updated url, takes it and sends it to BrowserRouter
  - BrowserRouter communicates the url down to all the different Route components
  - Route components rerender to show new set of components depending upon the path that the user is visiting.
- So when you make use of the 'Link tag', we are not dumping all of our react and JS data, we are just showing a different set of components on the screen.
- This is where Singl Page App(SPA) comes from.
  - It means that we are only loading up a single HTML document. 
  - We still allow the user to navigate around the application by clicking on various link tags.
  - But when they navigate around, they still are making use of the same document. 
  - We are just showing and hiding different sets of components based upon the url. 
  - This is how we handle navigation inside react router application. 
  - We are essentially tricking the user into thinking that they really are going to different pages. 
  - But in fact, we are just showing in hiding different components. 

## 82. Different Router Types

- BrowserRouter
  - Uses everything after Top Level Domain(.com, .net) or port as the 'path'
  - ex : localhost:3000/pagetwo
- HashRouter
  - Uses everything after a # as the 'path'
  - ex : localhose:3000/#/pagetwo
- MemoryRouter
  - Does not use the url to track navigation (same url wherever you go)
  - ex : localhost:3000/
- Deploy BrowserRouter could be very challenging.
- What is going on behind the scenes with the BrowserRouter
  - If you ask react development server for some resource that some route that is not defined, rather then returning a 404 error, the react app development server is going to respond with your index.html file and that is the key to how all of browser router works. 
  - If you ask for any route whatsoever, the react server is going to always respond with index.html file as opposed to returning a 404 error. 
  - This is important because all of our definitions are stuffed into the JS or client side of application. 
  - So an user goes over to our application and they click on link to navigate over to pagetwo and we refresh the page, we are making a request to our server for the route /pagetwo. 
  - And our dev server, if you click on the request and then click on response in network tab, it decides automatically return the html file. 
  - After browser loads up all html, it sees that there is a link inside, bundle.js file that contains all of our applications code. So Application loads up -> react router loads up -> history object that is created by BrowserRouter, inspects current url -> It seems that we are at the route of '/pagetwo' or whatsoever -> the history object tells the BrowserRouter, we are at '/pagetwo' -> BrowserRouter object tells routers inside of the object that we are at '/pagetwo' so render yourself appropriately.
- This mechanism of always responding with HTML file if route is undefined is not typical in any traditional server.
- Therefore, this is why it is so challenging to set up or deploy an application that makes use of the BrowserRouter.
- HashRouter
  - With HashRouter, you are supposed to be setting up your backend server do not take a long at anything after the hash.
  - If anyone ever makes requests to localhost:3000, you are always going to respond with index.html file. 
  - And your application loads up, the application will then look at whatever is after the hash and then use that to determine what content to show on the screen. 

## 83. Component Scaffolding

- Index Page : StreamList (/)
- Show Stream : StreamShow (/streams/show)
- Create Stream : StreamCreate (/streams/new)
- Edit Stream : StreamEdit (/streams/edit)
- Delete Stream : StreamDelete (/streams/delete)

## 84. Always Visible Components

- We want our head component to always be visible no matter what url, user is trying to look at. 
- In order to do so, we are going to add the header component to our app component outside of the BrowserRouter.
- If we have a component that is not listed inside the BrowserRouter, it will always be shown 100% of the time irrespective of what the current path is. 

## 85. Link Inside Routers

- Error : You should not use 'Link tag' outside a 'Router' occurs
- The error saying that any component that is not a child of our router cannot contain any react router related components. 
- So we are going to make sure that the App component renders the browser router as it still is but we are going to simply take our Header component and move it underneath the BrowserRouter.
- Because the Header component is not going to be wrapped up inside of route, the header will continue to always be visible. 
- BrowserRouter 아래에 있지만 Header 컴포넌트에 Route를 사용하지 않음으로써 화면에 렌더링되게 만든다는것. 
- So the Header component is a child of the BrowserRouter and so it can successfully make use of a link element.
  ```js
  </BrowserRouter>
      <div>
      <Header />
      <Route path="/" exact component={StreamList} />
      <Route path="/streams/new" exact component={StreamCreate} />
      <Route path="/streams/edit" exact component={StreamEdit} />
      <Route path="/streams/delete" exact component={StreamDelete} />
      <Route path="/streams/show" component={StreamShow} />
    </div>
  </BrowserRouter>
  ```

## 86. OAuth-Based Authentication

- Email/Password Authentication
  - We store a record in a database with the user's email and password. 
  - When the user tries to login, we compare email/pw with whats stored in DB.
  - A user is 'logged in' when they enter the correct email/pw.
- OAuth Authentication
  - User authenticates with outside service provider (Google, Linkedin, Facebook).
  - User authorizes our app to access their information.
  - Outside provider tells us about the user.
  - We are trusting the outside provider to correctly handle identification of a user.
  - OAuth can be used for user identification in our app and our app making actions on behalf of user.
  - So OAuth is not only about authentication but also about letting our application get access to all that user's data on some outside service provider. 

## 87. OAuth for Servers vs Browser Apps

- OAuth for Servers
  - Results in a 'token' that a server can use to make requests on behalf of the user.
  - Usually used when we have an app that needs to access user data when they are not logged in.
  - Difficult to setup because we need to store a lot of info about the user.
- OAuth for JS Browser Apps
  - Results in a 'token' that a browser app can use to make requests on behalf of the user.
  - Usually used when we have an app that only needs to access user data while they are logged in.
  - Very easy to set up thanks to Google's JS lib to automate flow.
- Google OAuth Login Flow
  - User clicks 'Login with Google' button
  - We use google's JS lib to initiate OAuth process
  - Google's JS lib makes auth request to Google
  - Google displays confirmation screen to user in popup window
  - User accepts
  - Popup window closes
  - Google's JS library invokes a callback in our React/Redux app
  - Callback provided with 'authoriztion' token and profile info for user
  - If user happens to log out our application or Google servers, we are going to get another callback invoked. 
  - This callback is going to say 'user just logged out'.

## 88. Creating OAuth Credentials

- Steps for Setting Up OAuth
  - Create a new project at console.developers.google.com/
  - Set up OAuth confirmation screen
  - Generate an OAuth Client ID
  - Install Google's API library, initialize it with the OAuth Client ID
  - Make sure the library gets called anytime the user clicks on the 'Login with Google' button.

## 89. Wiring Up the Google API Library

- Unfortunately Google themselves do not offer the library over npm, we are just going to add a manual script tag into the index.html. 
  ```js
  <script src="https://apis.google.com/js/api.js"></script>
  ```
- In order to check the code is working, type `gapi` in console. If it is, you are going to see object `{load: f}`.
- So we are going to create a new React component that is going to essentially wrap the Google library and make sure our user do the entire OAuth process. 
- When you print out gapi in console, you will see that it only has a single function tied to it called `{load: f}`. 
- load means load up some internal library by making a follow up request over to Google servers and fetching some additional amount of JS code and then adding it essentially to Google library. 
- To do so, we are going to call `gapi.load` and then we are going to pass in a `'clint:auth2'`.
- gapi.load(`'client:auth2'`)
- we can run that line of code and we will see the additional request automatically made to fetch some additional JS code and load it up into that library.
- then we type `gapi` again, some additional properties have been added inside of the object. 
- After we load up the additional library, we can then register or initialize it with our OAuth client id by calling 'gapi.client.init({clientId:'your cliend Id'})'
- gapi -> gapi.load('client:auth2') -> gapi.client.init({clientId: 'your cliend Id'})
- We want to make GoogleAuth component loads up the client portion of the library one time when the component is first rendered onto the screen.
- In order to do that, we are going to use componentDidMount lifecycle in the component.
```js
componentDidMount() {
  window.gapi.load("client:auth2");
}
```
- So now, anytime that the GoogleAuth component is rendered onto the screen, we are going to try to load up the client portion of the library. 
- When we load up that library, it takes some amount of time for the library to reach over to Google servers and download some additional JS code. 
- Therefore, we need to get a callback of when that process is completed.
- And the callback function is only going to be called after `client:auth2` library has been successfully loaded up gapi. 
  ```js
  componentDidMount() {
    window.gapi.load("client:auth2", () => {
      window.gapi.clinet.init({
        clientId:
          "wfeiooqwi5494411119641"
      });
    });
  }
  ```
- So after we successfully load up the client library, we are going to initialize our application with the clientId that we had generated. 
- And also we have to put another option in addition to clientId. It is `scope`.
- In scope property, we are going to specify the different scopes that we want to load up when we take user or we want to fetch when the user goes through OAuth process. 
- (Scope is essentially talking about what different parts of the user's profile, email or the user account that we want to get access to)
- We want to access user's email. so add email as a string. 
  ```js
  componentDidMount() {
    window.gapi.load("client:auth2", () => {
      window.gapi.client.init({
        clientId:
          "wfeiooqwi5494411119641.apps.googleusercontent.com",
        scope: "email"
      });
    });
  }
  ```
- But it is just going to initialize the library.
- It is not going to actually take the user goes through OAuth process. 

reference : https://developers.google.com/api-client-library/javascript/reference/referencedocs#gapiauth2getauthinstance

## 90. Sending a User Into the OAuth Flow

- In console, get a reference to that auth instance object.
  ```js
  const auth = gapi.auth2.getAuthInstance()
  ```
- variable auth contains many objects and you can check those in documentation.
- Trigger the flow for the user manually. 
  - so rather than clicking on any button or anything like that, we are going to just try to manually use methods we got to get the user to signIn.
  - Basically we need to call signIn method. 
  - When you call signIn method. login popup window apprears.
  - In order to check that user is signed in, type `auth.isSignedIn.get()`.
- Just for a note, in theory if we had asked for any other scopes around this user such as ability to modify their email or their Google Drive files, we could now use this library to modify those files or those emails.

## 91. Rendering Authentication Status

- What we are going to do?
  - Get a reference to the `auth` object after it is initialized.
  ```js
  const auth = gapi.auth2.getAuthInstance()
  ```
  - Figure out if the user is currently signed in.
  - Print their authentication status on the screen.
- When we loaded up `client:auth2`, we had to pass in callback function that was that invoked after additional module inside of the library was successfully loaded up.
- Similar fashion, when we call `gapi.client.init`, it executes an asynchronous network request over to Google's API server in order to initialize our client. 
- So we want to get some type of callback function or some type of notice for when that initialization set up is all done. 
- So we are going to .then statement
- Inside of then, we can write some amount of code that will be only executed once our entire gpi library is ready to go. 
- Which means inside of then method, we can start to figure out whether or not the user is currently signed in and then attempt to print out that status on the screen.
  ```js
  componentDidMount() {
    window.gapi.load("client:auth2", () => {
      window.gapi.client
        .init({
          clientId:
           "wfeiooqwi5494411119641.apps.googleusercontent.com",
          scope: "email"
        })
        .then(() => {
          this.auth = window.gapi.auth2.getAuthInstance();
        });
    });
  }
  ```
- After running .then method, inside of any other function inside my class, I can reference `this.auth`.
- This will give me a reference to that auth instance that I can use to sign the user in or sign them out or get the users current authentication status.
- But keep in mind that when the component gets called, our component has already been rendered to the screen. 
- So now if we want to update the text or what content the component shows, we need to somehow get the component to rerender. 
- Therefore we are going to be making use of component level state.
- When we update the state, it will cause the component to automatically render and we can then print up the authentication status on the screen.
  ```js
  state = { isSignedIn: null };
  
  componentDidMount() {
    window.gapi.load("client:auth2", () => {
      window.gapi.client
        .init({
          clientId:
           "wfeiooqwi5494411119641.apps.googleusercontent.com",
          scope: "email"
        })
        .then(() => {
          this.auth = window.gapi.auth2.getAuthInstance();
          this.setState({ isSignedIn: this.auth.isSignedIn.get() });
        });
    });
  ``` 
- For a quick note from future, If you want to sign in or sign out at this stage, you have to manually type in `gapi.auth2.getAuthInstance().signIn()` or `gapi.auth2.getAuthInstance().signOut()`.

## 92. Updating Auth State

- Login or Logout state does not rerender on a screen automatically. We have to keep refresh the page in order to see the changed login status.
- In order to make the state rerender on a screen we are going to use another method in `getAuthInstance()`.
- In `isSignedIn` method inside of `getAuthInstance()`, there are couple of methods we can find. 
- These are private functions that we are not supposed to call. 
- It links to prototype property and the it has `listen` method.
- So we can pass *callback function* to listen method. 
- If we do that, listen method will be invoked anytime that users on authentication status is changed. 
- So we can setState inside of listen method and then somehow we could update the text inside the header anytime user signs in or signs out.
  ```js
  componentDidMount() {
    window.gapi.load("client:auth2", () => {
      // it returns promise
      window.gapi.client
        .init({
          clientId:
            "wfeiooqwi5494411119641.apps.googleusercontent.com",
          scope: "email"
        })
        .then(() => {
          this.auth = window.gapi.auth2.getAuthInstance();
          this.setState({ isSignedIn: this.auth.isSignedIn.get() });
          this.auth.isSignedIn.listen(this.onAuthChange);
        });
    });
  }

  onAuthChange = () => {
    this.setState({
      isSignedIn: this.auth.isSignedIn.get()
    });
  };
  ```

## 93. Redux Architecture Design

- How to setup Google OAuth using redux?
  - Inside of GoogleAuth Component, we have got onSignIngClick, onSignOutgClick.
  ```js
  onSignInClick = () => {
    this.auth.signIn();
  };

  onSignOutClick = () => {
    this.auth.signOut();
  };
  ```
  - Whenever we call those methods, we are going to be accessing the Auth2 instance and that is going to start either signIn flow our signOut flow. 
  - Either way, the library is going to eventually call onAuthChange method inside of the component. 
  - In order to integrate redux into this flow, we are going to make sure that anytime that onAuthChange is called, we call some appropriate action creators. 
  - Action creator called something like signIn or signOut.
  - These action creators are called when user successfully signs in or signs out.
  - When we call action creators and they will return in action.
  - That action is going to show up in a reducer called something like AuthReducer.
  - The reducer probably going to be an object or something like that and holds simple boolean value that reflects whether or not the user is currently signed in or signed out.
  - But we already have boolean value inside of GoogleAuth component.
  - because GoogleAuth components is already holding the value.
  ```js
  renderAuthButton() {
    if (this.state.isSignedIn === null) {
      return null;
    } else if (this.state.isSignedIn) {
      return (
        <button className="ui red google button" onClick={this.onSignOutClick}>
          <i className="google icon" />
          Sign Out
        </button>
      );
    } else {
      return (
        <button className="ui red google button" onClick={this.onSignInClick}>
          <i className="google icon" />
          Sign In with Google
        </button>
      );
    }
  }
  ```
  - Answer is we are going to need login state many other places inside of the app.
  - If we store the value inside of state which is central place where the data is stored, through reducer it would be easier to get access no matter where we are. 

## 94. Connecting Auth with Action Creators

- Create action creators
```js
  export const signIn = () => {
  return {
    type: "SIGN_IN"
  };
};

  export const signOut = () => {
    return {
      type: "SIGN_OUT"
    };
  };
```
- Wire up GoogleAuth component with action creators.
- And put it into onAuthChange method
  ```js
  onAuthChange = isSignedIn => {
    if (isSignedIn) {
      this.props.signIn();
    } else {
      this.props.signOut();
    }
  };
  ```
- Depends what argument onAuthChange component will get, action that is going to be dispatched will be different.
- onAuthChange 함수가 `this.auth.isSignedIn.listen`의 인수로 들어가게 되는데 `listen`은 boolean 값만 인수로 받는다. 즉 onAuthChange의 값은 boolean 값이라는것이며 그 값은 `isSignedIn`에 있는것 (아직 답변이 없으므로 이렇게 예상한다.)

## 95. Building the Auth Reducer

- Create reducer name authReducer.
- reducer has default state in form of object because we are going to eventually have one other property related to authentication.
- But we are going to need default state of null in this case so we are going to create initialiser.
- So in addition to having just some boolean value or no value to indicate whether or not the user signed in, we are going to have some other piece of data inside of the object. 
- And the easiest way to arrange all these data is to make use of an object.
- But we probably start to off this property being set to null.
- So in order to initialize default argument of state, we are going to create an initializer above the reducer.
  
  ```js
   export default (state = {}, action)  => {};

   // to

    // make variable name all capitalized to make other engineers know that this is supposed to be a true constant object, do not modify it.
    const INITIAL_STATE = {
    isSignedIn: null
  };
    export default (state = INITIAL_STATE, action)  => {};

    //to

    const INITIAL_STATE = {
    isSignedIn: null
  };

  export default (state = INITIAL_STATE, action) => {
    switch (action.type) {
      case "SIGN_IN":
      // spread syntax because I want to modify a property
        return { ...state, isSignedIn: true };
      case "SIGN_OUT":
        return { ...state, isSignedIn: false };
      default:
        return state;
    }
  };

  ```
- Last thing we have to do is communicate the state back over to the GoogleAuth component.

## 96. Handling Auth Status Through Redux 
- We have to Auth piece of state back into our GoogleAuth Component.
- We now essentially extracted that information to our redux store.
- So now we need to pipe the information back into the component that was already containing that data.
- It feels a little bit awkward to do it but this is correct way to do it.

## 97. Handling Auth Status Through Redux

- When we finished initializing our library, we are going to assign the auth instance to this.auth
  ```js
  this.auth = window.gapi.auth2.getAuthInstance();
  ```
- then we immediately update our state inside of our redux store,
  ```js
  this.onAuthChange(this.auth.isSignedIn.get());
  ```
- and then we will basically sit around and wait for the authentication status to change at some point in the future
  ```js
  this.auth.isSignedIn.listen(this.onAuthChange());
  ```
- 정리 
  - 구글 로그인 버튼을 클릭
  - `onSignClick` 함수가 실행되고 그 안에있던 로그인을 실행하게 하는 `this.auth.signIn()`이 따라서 실행된다.
  - `this.auth.signIn()`이 실행됨에 따라 auth의 `this.auth.isSignedIn.get()`의 상태가 달라지므로 action을 실행하기 위해 `this.onAuthChange`의 인수로 넣어준다.
  - 여기까지가 구글 API를 사용한다. 
  - Boolean 값을 받은 `onAuthChange` 함수는 action creator를 실행시킨다.
  - action -> reducer로 실행이된다.
  - `mapStateToProps`로 상태를 받아와 기존에 this.state를 사용하던 `renderGoogleButton`에서 this.state를 지우고 대신 reducer에서 받아온 상태를 사용해준다
  - 구글API에서 가져온 로그인 정보는 `onAuthChange`에서 action creator를 실행시킬때 사용하며 redux store에 있는 정보는 로그인버튼 보여줄때 사용함. 
  
## 98. Fixed Action Types

- When login button is clicked, nothing might be happening.
- This is a common bug 
- In order to prevent this situation, create a new file name types.js in action folder.
- And set actions value as a variable.
  ```js
  export const SIGN_IN = "SIGN_IN";
  export const SIGN_OUT = "SIGN_OUT";
  ```

## 99. Recording the User'sID

- Some point in time, we need to make sure that each stream is somehow associated with the user who created it (delete, edit etc).
- In order to do so, we are going to create each stream record inside the API server that contains the ID of the user who created it.
- We can find the username using.
  ```js
  gapi.auth2.getAuthInstance().currentUser
  ```
- This contains information about the user who is currently signed in to our application.
- Inside of this current object, we can find Google ID for this user.
- When user login using Google account, Google assigns them ID automatically. 
- Therefore, use this ID, we can track which user created which stream.
- We can find ID that assigned by Google using this
  ```js
  gapi.auth2.getAuthInstance().currentUser.get().getId() // 11115784693215
  ```
- So we want to essentially store this ID inside of our auth reducer. 
- In order to mark which user created the stream very easily by using ID
  - pass `this.auth.currentUser.get().getId()` as an argument when user signs in.
  ```js
  onAuthChange = isSignedIn => {
    if (isSignedIn) {
      this.props.signIn(this.auth.currentUser.get().getId());
    } else {
      this.props.signOut();
    }
  };
  ```
  - So now when we call this action creator, we are going to also pass on the idea of the user who has signed in.
  - And change action creator and reducer a bit. (both have to receive userId)
  ```js
  // action creator
  export const signIn = userId => {
  return {
    type: SIGN_IN,
    payload: userId
    };
  };
  // reducer
  const INITIAL_STATE = {
    isSignedIn: null,
    userId: null
  };

  export default (state = INITIAL_STATE, action) => {
    switch (action.type) {
      case SIGN_IN:
        return { ...state, isSignedIn: true, userId: action.payload };
      case SIGN_OUT:
        return { ...state, isSignedIn: false, userId: null };
      default:
        return state;
    }
  };
```
```

## 100. Using Redux Dev Tools to inspect the Store

- Install redux-devtools-extenstion from https://github.com/zalmoxisus/redux-devtools-extension
- This is extension that is going to allow you to very easily debug redux store. 
- But the extension is available only for Chrome and Firefox.
- And configure according to Advanced store setup.

## 101. Debug Sessions with Redux Dev Tools

```js
localhost:3000?debug_session='random String'
```
- With this address, redux dev tools is going to see that you are trying to start up a debug session.
- Debug session is where redux dev tools is going to automatically save all of the data inside of your redux store and persist it across refreshes of you application.
- So when you enable this debug session, redux dev tools is going to make sure that all the data stays around between refreshes of the page. 
- This is incredibly useful when we start doing some advanced feature development. 

## 102. Form with Redux Form

- install redux form on npm.
- How have we handled form up to this time in react. 
  - state -> input element value -> input element onChange -> setState -> state
- Using redux, we are going to store input data inside of redux store and anytime a user changes an element, we are going to call an action creator. And that is going to attempt to change that data inside of a redux store.
- Handling inputs with Redux Form
  - We are going to have some reducer that is going to hold all the states of our different form inside of our application.
  - So that might be value of some input element or the selection of some dropdown or the current checkboxes that are checked inside of application. 
  - Essentially all of form data is going to exist inside of our redux store and all that form data is going to be maintained by a reducer. 
  - Then in order to make sure that we can get the data from that store into our input elements whatever user types in, they are going to have mapStatetoProps. 
  - It is going to take the data out of the redux store and get it into our component as props.
  - So we are going to take that props object and all the different values inside there and pass them into our different input elements as values.
  - Then anytime user makes a change to an element, we are going to have some callback handler inside of our component.
  - That is going to call action creator and try to update the form data inside of a redux store.
- Good thing is redux form is essentially going to do all of that stuff for us.
  - redux form includes reducer, mapStateToProps function, action creator.
  - Only thing that we have to do is make sure that we eventually get some form information in a component down into some given input element.
  - And make sure that the input element understands that it needs to call some callback handler provided redux form anytime that gets changed. 

## 103. Connecting Redux Form

- Wire up redux form library inside of index.js in reducers file.
  ```js
  import { reducer as formReducer } from "redux-form";

  export default combineReducers({
    auth: authReducer,
    form: formReducer
  });
  ```


## 104. Creating Forms

- In StreamCreate.js file, import `Field`, `reduxForm` from `redux-form`
  ```js
  import { Field, reduxForm } from "redux-form";
  ```
- `Field` is supposed to be a react component that eventually showed on a screen.
- `reduxForm` is a function (It has exact same functionality as connect function from react-redux library).
- `reduxForm` makes sure we can call action creator and get some form data into a component. And that happens automatically.
- Set `reduxForm` function just like connect in react-redux
  ```js
  // reduxForm returns a function and we immediately call that function with StreamCreate
  export default reduxForm()(StreamCreate);
  ```
- However, unlike connect function, `reduxForm` receives single object and we are going to put configuration into that object.
  ```js
  export default reduxForm({ form: 'streamCreate'})(StreamCreate);
  ```
- Since `StreamCreate` has hooked up redux form, the component is now going to be passed many additional props that it was not being passed before.
  ```js
    class StreamCreate extends React.Component {
    render() {
      // you can check props using consol.log
      console.log(this.props);
      return <div>StreamCreate</div>;
    }
  }
  ```
- So essentially we are able to pick through the list of props that `StreamCreate` passed in, find the different props that are relevant and make use of them to actually build out our form.
- We make use of the `Field` component anytime that we want to show a field to the user. 
  ```js
  class StreamCreate extends React.Component {
    render() {
      return (
        <form>
          <Field />
        </form>
      );
    }
  }
  ```

- Whenever we place a `Field` component, we are always going to provide it some number of props. 
- name prop is always required inside of `Field` component. It is a name of the property that field is going to manage.
- The names we are going to put together are `Title` and `Description`.
```js
  <Field name='title'/>
  <Field name='description'/>
```
- But you are going to see the error message frequently saying 
  `Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: undefined. You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.`
- Because when we show this `Field` component, the `Field` itself has no idea how to render some type of input element on the screen. So a `Field` does not know how to show a text input, checkbox, dropdown etc.
- A `Field` is just a component that is going to be part of the system that is going to automatically handle all of the forms put together but it individually is not responsible for actually getting to show up on the screen.

## 105. Automatically Handling Events

- In order to tell `Field` component how to show an actual text input on the screen, we have to assign a prop to it called `component`. 
- `Component` props is going to be either a real component or a function for the field to call.
- It needs to return some element that is going to actually be shown on the screen. 
```js
  <Field name='title' component={} />
  <Field name='description'/>
```
- Therefore *`Field` element in total is really just about hooking up all of the infrastructure that redux form is actually doing for us.* When we actually want to show some content or some form element on a screen, it is up to us to show the actual input element and customize it in some fashion.
- We can do so using `component` props. 
- We are going to create helper method and wire it up with `component` props.
```js
class StreamCreate extends React.Component {
  renderInput() {
    return <div>I am an input</div>;
  }

  render() {
    return (
      <form>
        <Field name="title" component={this.renderInput} />
        <Field name="description" component={this.renderInput} />
      </form>
    );
  }
}
```
- And now, we can check that two `I am an input` rendered on a screen.
- Here is important lesson:
  - Redux form is about automating many processes such as making sure that your form data is inside the redux store, getting that data back into the component and helping you getting the data into the appropriate input elements. 
  - *However, redux form does not really know a lot about what you are doing!*
  - It does not know you are showing a text input.
  - It does not know you are showing a dropdown.
  - It does not know you are showing a checkbox.
  - It does not know you are not showing any input element at all.
  - Redux form is just kind of going to assume that you are doing the correct thing.
- So to do things the right way, we are going to return an input element.
```js
renderInput() {
  return <input />
}
```
- But it is not controlled input.
- Anytime that the `Field` tag calls `this.renderInput`, it is going to pass in some number of arguments. 
- First, pass `formProps` into an argument and console.log it.
```js
renderInput(formProps) {
  console.log(formProps);
  return <input />;
}
```
- Inside of formProps object, we have keys of input and meta.
  - input property has actual `Field` name of title. 
  - So the object is meant to essentially be customizing the input.
  - Inside of input properties, we can find many familiar looking callback handlers including `onChange` and `value` props.
  - So our job is take that onChange handler and wire up into input element, take the value prop and hook it up to the input element as well.
- So essentially we are supposed to take these formProps, take the input property out of it and hook up the relevant properties to the text input. 
```js
renderInput(formProps) {
    return (
      <input
        onChange={formProps.input.onChange}
        value={formProps.input.value}
      />
    );
  }
```
- Everytime that you create a new form through
```js
reduxForm({
  form: "streamCreate"
})(StreamCreate);
```
- You pass the property name `form`.
- Whatever name of object you put inside of first argument of `reduxForm`, `reduxForm` is going to start to store all the values for inside of it. (`reduxForm`을 이용해 유저가 form을 생성하게 되면 이 객체의 값, 여기서는 streamCreate에 저장된다는것.)
- There is another way to shorten the syntax of `renderInput` method.
```js
renderInput(formProps) {
    return (
      <input {...formProps.input}/>
    );
  }
```
- `...formProps.input` takes all those key value pairs and add them as properties to the input element. 
- So essentially take that entire input object, take all the properties out there and add them as props to the input element. 
- We can destructure the syntax
```js
renderInput({ input }) {
    return <input {...input} />;
  }
```

## 106. Customizing Form Fields

- When we pass elements to `Field` component, it does not know what to do with it
- Therefore we have to pass those elements in argument of `renderInput` to render on a screen.
```js
renderInput({ input, label }) {
    return (
      <div className="field">
        <label>{label}</label>
        <input {...input} />
      </div>
    );
  }

  render() {
    return (
      <form className="ui form">
        <Field name="title" component={this.renderInput} label="Enter Title" />
        <Field
          name="description"
          component={this.renderInput}
          label="Enter Description"
        />
      </form>
    );
  }
```

## 107. Handling Form Submission

- Inside of props that received by redux form library, it contains `handleSubmit` callback function. 
- We then call that function with `onSubmit` callback method that we defined inside of the component.
```js
onSubmit(e) {
    e.preventDefault();
  }

<form onSubmit={this.props.handleSubmit(this.onSubmit)} className="ui form">
```
- When we go through this entire process, it is going to change exactly how `onSubmit` gets called.
  - Internally whenever the form gets submitted, now `handleSubmit` is going to automatically receive that event object and automatically call `preventDefault()` for us.
  - Redux form takes care it for us.
  - In fact, `onSubmit` does not need `e` at all. Instead it is going to be called with whatever values existed inside of our two inputs.
  - So usually we refer to the argument something like as `formValues` 
  ```js
  onSubmit(formValues) {
    console.log(formValues);
  }
  ```
  - formValue argument contains the inputs that user typed and submitted.

## 108. Validation of Form Inputs

- Steps for validation
  - Form is initially rendered OR user interacts with it 
  - Redux calls function `validate`.
    - The function is going to be called with all the current values in the form.  
    - The function is going to be essentially the opportunity to check to see if the user entered is valid or invalid input.
  - After we do series of if statment that input is whether valid or invalid below,
  ```js
    const validate = formValues => {
    console.log(formValues);
    if(!formValues.title) {
    
    }
  };
  ```
  if user returns valid input, we are going to return an empty object.
  - When we return an empty object that essentially tells redux form that nothing is wrong with our form and it is completely valid and the user can submit it if they want to.
  - But if a user did anything incorrectly then we are going to return an object. 
  - Each invalid field that user enters, we are going to put a key value pair on an object with the name of the fields that the user entered in and error message to show to the user. 
    - for example, if user inputs invalid title -> `errors = { title:'You must enter a title'}`
  - When redux forms sees the object, it is going to think that there is a value inside the object that means the user must have done something incorrectly.
  ```js
    const validate = formValues => {
    const errors = {};
    if (!formValues.title) {
      errors.title = "You must enter a title";
    } else {
      errors.description = "You must enter a description";
    }
    return errors;
  };
  ```
  - *In order words, if we return empty object from `validate` redux form assumes that everything went OK. So it is only when we put a key value pair into the object that redux form realizes that something just went wrong*

## 109. Displaying Validation Message

- Wire up `validate` function to redux form
  ```js
    export default reduxForm({
    form: "streamCreate",
    validate
  })(StreamCreate);
  ```
- So we have wired `validate` function up to our component.  
- `validate` function is going to be called every single time that the form is initially rendered or the user interacts with it anyway.
- Now our `validate` function is getting called. 
- If we return the object from the `validate` function then redux form is going to automatically rerender our component.
- To actually get these error messages to appear on a screen, redux form is going to take a look at every `Field` component that gets rendered in order words, It is going to look at each `Field` name property.
- And then it is going to look at the errors object that we return from `validate`.
- If `Field` has same name as a property that exists inside that object then redux form is going to take the message and pass it to our `renderInput` fuction. Idea is that our errors object has property name that is identical to the name property inside of `Field` component and it contains a string that error message will be passed down to `renderInput` function. 
- *Remember that the big connection between the `validation` function and getting the message into `renderInput` function is all about the `Field name`.*
- We can check error message using `meta` property.
  ```js
  renderInput({ input, label, meta }) {
    return (
      <div className="field">
        <label>{label}</label>
        <input {...input} />
        <div>{meta.error}</div>
      </div>
    );
  }
  ```
- 정리
  - 입력된 값을 판별하기 위해 `validate` 함수를 만들어준다.
  - `validate` 함수는 `errors`라는 빈 객체를 가지고있다.
  - 만약에 `formValues`에 `title`과 `description`이 없는경우에는 `errors`라는 객체에 메세지를 넣을것
  - 하지만 두가지 모두 있을경우에는 빈 객체를 반환한다.
  - `validate` 함수를 `reduxForm`에 연결시킨다.
  - `reduxForm`에 연결시키게 되면 redux form은 자동적으로 `errors`객체안의 프로퍼티 이름과 `Field`컴포넌트안에 있는 이름을 비교한다.
  - 만일 같은 이름이 존재할 경우 `Field` 컴포넌트와 연결되어있으며 `renderInput` 함수로 전달되어진 `formProps` 인수의 `meta` 프로퍼티 `error`의 값으로 `validate` 함수에서 생성이 된 객체의 값이 들어가게된다. 

## 110. Showing Errors on Touch

- We got error message to print up underneath each field. 
- But we want to show this error message whenever a user submits the form.
- We want to show the error message after the user clicks into a field, enter some text and then clicks out of it.
- We are going to use `touched` property in `meta` property to do it.
- If `touched` is equal to true, we probably want to take that as an opportunity to show our error message to the user.
- And vice versa.
- We are going to use helper function to do it inside of `renderInput` function.
  ```js
  renderError({ error, touched }) {
    if (touched && error) {
      return (
        <div className="ui error message">
          <div className="header">{error}</div>
        </div>
      );
    }
  }
  renderInput({ input, label, meta }) {
    console.log(meta);
    return (
      <div className="field">
        <label>{label}</label>
        <input {...input} autoComplete="off" />
        {this.renderError(meta)}
      </div>
    );
  }
  ```
- But you are going to see error message `TypeError: Cannot read property 'renderError' of undefined`.
  - The error comes from `renderError` function.
  - Because when `renderInput` is called inside of `Field` component, it is going to be called with unknown value of `this`. In other words the keyword `this` inside of `renderInput` is going to be known to us.
  - So we are going to turn `renderInput` function to arrow function syntax. (it is okay to turn `renderError` function to arrow funtion as well)
  ```js
   renderInput = ({ input, label, meta }) => {
    console.log(meta);
    return (
      <div className="field">
        <label>{label}</label>
        <input {...input} autoComplete="off" />
        {this.renderError(meta)}
      </div>
    );
  };
  ```
- However even if we click in and click out input fields, we still do not see any error message that we intend. 
- But if you check Elements tab in developer console, you can check the error message!
- *The problem is the fact that semantic UI by default is going to hide error messages. It sets `display:none`*
- Do it like below to set css.
  ```js
  <form onSubmit={this.props.handleSubmit(this.onSubmit)} className="ui form error">
  ```

## 111. Creating Streams

- The real question is how do we communicate from our react application up to API server and tell the API server that there is now a new stream that is available for viewing. 
- We are trying to take the title and description and put it up to API server so that other users can fetch a list of all the different available streams.
- Our API server is essentially going to have a plain list of records. Each record is going to represent one individual stream and each stream is going to have ID, a title of the stream and a description in a form of object
  ```js
  {id:1, title 'My Stream', description: 'Some stream'}
  {id:2, title 'Code Stream', description: 'Coding'}
  ```
- So we are going to take the list of streams right from API server and send them down to our react application and show them on the screen.
- Then whenever a user selects a stream, we are going to make sure that our react application reaches out to the RTMP server and the server is going to take whatever stream with id is coming in and stream that video over to our react application.
- Streamer's computer creates stream id 2 -> RTMP -> API Server -> When viewer asking the stream id 2 -> API server responses to viewer.
- Therefore, we are going to take the title and description from our form and try to create some new record on that API server. 

## 112. REST-ful Convertions

- We are going to put together with API server using `JSON Server`.
- The reason of using `JSON Server` because it has a extremely strict adherence to RESTful conventions. 
- REST Conventions
  - It is a predefined system for defining different routes on a API that work with a given type of records.
  - In order words, the term RESTful convetions is essentially referring to a standardized system of routes and request methods used to commit or operate all different actions.
  - But we do not have to define a API server to behave in any which way. We can have it behave in anyway we want.
  - However in order to make our API is easier to work with for like other engineers, we usually try to do follow these restful conventions.
- We are going to create a new folder name `api` outside of `client` folder and create `db.json` file inside of it (we are using different terminal).
- `db.json` file works as a database.
  ```js
  {
  "streams": []
  }
  ```
- Add command in scripts in `package.json` file.
  ```js
  "scripts": {
    // start command is going to start up the JSON server running on port 3001 and it is going to watch db.json file for any changes that get made to it. 
    "start": "json-server -p 3001 -w db.json"
  },
  ```
- That is literally all the code we have to write to get the API server up and running. 
- And type `npm start` to start up the server in port 3001.
- So now we have a listed resource at `localhost:3001/streams`.
- We can make use of this JSON server to manupulate the list of streams that are stored inside the API server by following of REST-ful conventions.
- So if we want to get a list of our streams we are going to make a `get, post, delete etc` request to `localhost:3001/streams`.

## 113. Creating Streams Through Action Creators

- We have our API server put together, we need to make sure that anytime that user submits the form in `StreamCreate` component, we attepmt to make ajax request or a network request over to our API running on `localhost:3001`.
- So to make a network request, we are going to first define an action creator.
- We are going to make use that we wire up that action creator to our component through the `connect` function.
- We are going to call the action creator from `onSubmit` function. 
- And then the action creator is going to use `axios` to make the network request over to our API.
- Setting up `axios` in `streams.js` file in `apis` folder
  ```js
    export default axios.create({
    baseURL: "http://localhost:3001"
  });
  ```
- After setting `axios`, create action creator `createStream`
  ```js
    // createStreams takes input value as formValues argument
    export const createStream = formValues => {
    return async dispatch => {
      streams.post('/streams', formValues)
    };
  };
  ```
- And wire up `connect` function and action creator in `StreamCreate` component.
- But we have one problem. because we have already wired up `redux form` exact same way as the `connect` function.
  ```js
    export default reduxForm({
    form: "streamCreate",
    validate
  })(StreamCreate);
  ```

## 114. Creating a Stream with REST Conventions

- It is going to be a little bit challenging to hook up both the `connect` function and `redux form` to this componnet.
  ```js
    const formWrapped = reduxForm({
    form: "streamCreate",
    validate
  })(StreamCreate);

  export default connect(
    null,
    { createStream }
  )(formWrapped);
  ```
- And set action creator `createStream` inside of `onSubmit` function
  ```js
   onSubmit = (formValues) => {
    this.props.createStream(formValues);
  }
  ```
- So now, whenever the user tries to estimate the form, we are going to validate the inputs. if the inputs are valid, we will call `onSubmit` and the function is going to call our action creator `createStream`, and then it is going to run the action creator and we are going to attempt to make a request over to our API server and create a new stream and we now that this is going to create a stream because we are following RESTful conventions.
- After we have wired up action creator, send a request to server after you fill out the form.
- When you check network tab in developer console, we are going to find out that there are two streams file have been sent to server. 
- One is OPTIONS request and the other one contains the contents that you have filled out in the form.
  ```js
  {title: "my stream", description: "i love it ", id: 1}
  ```
- And go back to `db.json` file in api folder and check that the request is inside of the file.
  ```js
    {
    "streams": [
      {
        "title": "my stream",
        "description": "i love it ",
        "id": 1
      }
    ]
  }
  ```
- Now let's make sure that streams that we created show on the original `StreamList` component.
- 정리 
  - JSON 서버와 통신할 API 파일을 만든다.
  - action creator를 이용해 서버와 통신할 것이다. 그러므로 redux-thunk가 필요하다.
  - 메인 index.js 파일에 redux-thunk와 applyMiddleWare를 import 한뒤에 연결시켜준다.
  - 서버에 데이터를 post할 action creator인 createBoard를 만들어준다. 
  - action creator를 만들어줄때 post할때는 서버에 유저가 입력한 내용을 보내줘야 하므로 매개변수 formValues를 받게 만들어준다.
  - 이제 connect를 이용해 BoardCreate 파일에 action creator를 연결시켜준뒤 form이 제출되면 작동되는 함수에 props로 formValues를 받은 action creator를 넣어준다. 

## 115. Dispatching Actions After Stream Creation

- We need to somehow get a handle on the response that comes back from the post request.
- Because it contains the actual saved record of the stream that we just created. 
  ```js
    export const createStream = formValues => {
    return async dispatch => {
      const res = await streams.post("/streams", formValues);
    };
  };
  ```
- So now we have a handle on the stream that just got created, we are probably going to want to dispatch an action with a payload that stream and then we can eventually create a reducer and pick up that stream that was created and save it inside there or whatever it is we want to do.
  ```js
    export const createStream = formValues => {
    return async dispatch => {
      const res = await streams.post("/streams", formValues);

      dispatch({type: CREATE_STREAM, payload: res.data})
    };
  };
  ```

## 116. Bulk Action Creators

- Since we follow the RESTful conventions, we know what results we expected. So it would be convenient to create action creators in advance. 
  ```js
  export const fetchStreams = () => {
    return async dispatch => {
      const res = await streams.get("/streams");

      dispatch({ type: FETCH_STREAMS, payload: res.data });
    };
  };

  export const fetchStream = id => {
    return async dispatch => {
      const res = await streams.get(`/streams/${id}`);

      dispatch({ type: FETCH_STREAM, payload: res.data });
    };
  };

  export const editStream = (id, formValues) => {
    return async dispatch => {
      const res = await streams.put(`streams/${id}`, formValues);

      dispatch({ type: EDIT_STREAM, payload: res.data });
    };
  };

  export const deleteStream = id => {
    return async dispatch => {
      await streams.delete(`streams/${id}`);

      dispatch({ type: DELETE_STREAM, payload: id });
    };
  };
  ```

## 117. Object-Based Reducers

- This time, instead of returning an array, reducer is going to return an object that has all the streams inside of it. 
- Inside of the object, we are going to have a collection of key value pairs.
- So in order to kind of access any given stream inside the object, we would just have to reference our streams piece of states out of our redux store and then essentially try to access the appropriate ID inside there. 
   ```js
  {
    1: stream with ID 1
    22: stream with ID 22
    37: stream with ID 37
  }
  ```
- And that will give us the stream that we are looking for.
- If we make use of object instead of array for reducer, the updating process would be much more straightforward.
- We would put down the curly braces to indicate a new object.
- We would take all the records out of our old state object and add them in and then we would add in a new key value pair.
- In this case, the key would be the ID of the stream that we just updated. 
  ```js
  {...state, 65: Stream65}
  ```
- So basically the syntax of updating our state is going to be so much easier when we are making use of an object instead of an array.

## 118. Key Interpolation Syntax

- Syntax of updating our state using object
  ```js
  const streamReducer = (state={}, action) => {
    switch(action.type) {
      case EDIT_STREAM:
        // const newState = {...state};
        // newState[action.payload.id] = action.payload;
        // return newState
        return {...state, [action.payload.id]: action.payload};
        default:
        return state;
    }
  }
  ```
- This is called key interpolation.
  ```js
  return {...state, [action.payload.id]: action.payload};
  ```
- So this essentially means we don't know exactly what key we want to add to the object.
- We know that `action.payload.id` property is the key that we want to add but we want to somehow add in that key when the code runs.
- The idea is whatever the number or string or value takes and creates a new key using it inside of overall object. 
- And to that key assigns `action.payload`.
- Easier Example
  ```js
  const animalSounds = { cat: 'meow', dog: 'bark'}
  const animal = 'lion'
  const sound = 'roar'
  {...animalSounds, [animal]:sound} // { cat: 'meow', dog: 'bark', lion: 'roar' }
  ```

## 119. Handling Fetching, Creating and Updating

- Create `streamReducer` file inside of reducer folder.
- It does all streams related works.
- Set up separate case statements to handle each of different types. And each of those different types has different response get back from the API.
- For example, when we see an action with the type of `FETCH_STREAMS` specifically that means we are getting back an array of records. And we are going to want to take that array of records and merge them all into the state object. 
  ```js
  export default (state = {}, action) => {
    switch (action.type) {
      case FETCH_STREAM:
        return { ...state, [action.payload.id]: action.payload };
      case CREATE_STREAM:
        return { ...state, [action.payload.id]: action.payload };
      case EDIT_STREAM:
        return { ...state, [action.payload.id]: action.payload };
      default:
        return state;
    }
  };
  ```
## 120. Deleting Properties with Omit

- In order to make `DELETE_STREAM`, we are going to use `_omit` in `lodash` library.
- Install `lodash` library and import it in `streamReducer` file.
  ```js
  case DELETE_STREAM:
      return _.omit(state, action.payload)
  ```
- But in this case, we do not have to reference `.id` property because in `DELETE_STREAM`, `action.payload` itself is the ID.
- Nice thing about `_.omit` is that it is not going to change the original state object. Instead it creates a new object with all the properties from states without whatever we passed in as the `action.payload`.
  
## 121. Merging Lists of Records 

- So now we are trying to make sure that we can take an array of streams from our API and merge them all into our state object.
- It would be easier if we dealing with array but since we are using an object, we have to figure out a clever solution.
- When we get a list of strings from the API, they come back in an array and each stream has an ID, title and description properties. 
- In order to get these array form of data merged into our obejct, we are going to use a function from `lodash` called `mapKeys`.
- It is a function that is going to take an array and then return an object.
- The keys of new object are going to be taken from each individual record inside of the array. 
- So we can call `mapKeys` and pass in the list of streams that we got from the API. And as the second argument, we will put in a string of ID. 
  ```JS
  mapKeys(streams, 'id')
  ```
- The string of ID tells `lodash` that every one of objects inside of the original array use a key taken from the id property of each one.
- (the data we get from the API is form of an array that objects are in it.)
- Essentially what we are going to do with `mapKeys(streams, 'id')` is 
  - Create a new object
  - Look at object inside of original array
  - Look at the id property of that object inside of the array
  - Whatever that value is, use id property as the key for the entire object that newly created. 
  - (Suppose, we use the object that contains `id:12` inside of the data that we fetched, `mapKeys` function is going to use it as key when it gets added into the new object. So essentially we create a new key of 12 and then we assign the original object to that key.)
  - Example:
  ```js
    const numbers = [
    { id: 3},
    { id: 5},
    { id: 7}
  ]
  _.mapKeys(numbers, 'id')
  //  key for each one is whatever the 'id' property was 
  // {"3":{"id":"3"}, "5":{"id":"5"}, "7":{"id":"7"}}
  ```
- Using `mapKeys` function, create a reducer.
  ```js
   case FETCH_STREAMS:
      return { ...state, ..._.mapKeys(action.payload, "id") };
  ```
- 정리 
  - db.json에서 가져온 배열형태의 데이터들을 lodash를 이용해 각 객체의 id가 키 값인 객체형태로 바꾸는것

## 122. Fetching a List of All Streams

- In order to show the streams at StreamList component as soon as it renders, we are going to change the component function base to class base and add `componentDidMount` lifesycle.
- After that, wire up `connect` function and `fetchStreams` action creator.
  ```js
  import React from "react";
  import { connect } from "react-redux";
  import { fetchStreams } from "../../actions";

  class StreamList extends React.Component {
    componentDidMount() {
      this.props.fetchStreams();
    }
    render() {
      return <div>StreamList</div>;
    }
  }

  export default connect(
    null,
    { fetchStreams }
  )(StreamList);
  ```

## 123. Rendering All Streams

- Now that we are loading up our list of streams into the application, we want to make sure that data get rendered out by the StreamList component. 
- The first thing we need to do is to make sure that we get our list of streams available as props inside of the component. 
- But here is the part that things get a little bit interesting.
- Our list of streams is actually stored inside of an object.
- We will leave data inside of obejct form because it makes it really easy to update add and delete records. 
- But when we eventually take these streams and get them into a component through `mapStateToProps`, usually we will turn that object into an actual array. 
- The reason of this is just to make sure that it is really easy to map over and run that `mapStateToProps` function.
- To get a list of just `state.streams` inside of an array and not have to worry about the object nature of the thing, we are going to call `Object.values` and then pass in state.streams.
  ```js
    const mapStateToProps = state => {
    return { streams: Object.values(state.streams) };
  };
  ```
- `Object.values` 
  - It is a built in JS function.
  - It is going to take an object as an argument.
  - All the different values inside of the object are going to be pulled out and then inserted into an array. 
- So now inside of the component, we are going to have a prop called `this.props.streams` and that is going to be an array of all of our different streams. 
- Create `renderList` function to take that list of streams and just render them out as a list on the screen.

  ```js
  renderList() {
    return this.props.streams.map(stream => {
      return (
        <div className="item" key={stream.id}>
          <i className="large middle aligned icon camera" />
          <div className="content">
            {stream.title}
            <div className="description">{stream.description}</div>
          </div>
        </div>
      );
    });
  }
  ```
- And renders the function inside of `render` method.
  ```js
  render() {
    return (
      <div>
        <h2>Streams</h2>
        <div className="ui celled list">{this.renderList()}</div>
      </div>
    );
  }
  ```

## 124. Associating Streams with Users

- We got the list of streams to render but remember that we want to show some buttons on individual streams that say delete and edit.
- These buttons should only be visible if I was the person who created the stream.
- So it is kind of good tie up for the authentication and fetching the list of streams part of the application.
- In order to figure out which stream was created by who, we need to actually attach a user ID to our streams when they get created. 
- So what we need to add on a userId to the stream object.
  ```js
  {
    id: 1,
    title: "my stream",
    description: "i love it"
    userId: "ID of whoever created this"
  }
- Essentially we need to somehow get our userId inside of our `createStream` action creator. 
- When we return a function from an action creator, the function gets called automatically by `redux thunk` with two arguements (`dispatch, getState`).
- `getState` function allows us to reach the redux store and pull out some piece of information. 
- So add `getState` argument inside of `createStream` action creator.
```js
export const createStream = formValues => {
  return async (dispatch, getState) => {
    const { userId } = getState().auth;
    const res = await streams.post("/streams", { ...formValues, userId });

    dispatch({ type: CREATE_STREAM, payload: res.data });
  };
};
```

## 125. Conditionally Showing Edit and Delete

- Now we have our streams associated with the user who created them, we are going to update our `StreamList` component and make sure that these streams that were created by me have buttons. 
- So we have to make sure that `StreamList` component understands the idea of the user who is currently signed into our application.
- We have already stored the information inside of redux store. 
- So essentially whenever we iterate thorugh the list of streams and render them out on the screen, we just want to compare the current userId with a userId associate at the stream. 
- If they are equal, then we want to show those buttons on the right hand side of each stream.
- To get the information of userId into our component, we need to use the `mapStateToProps` function.
```js
const mapStateToProps = state => {
  return {
    streams: Object.values(state.streams),
    currentUserId: state.auth.userId
  };
};
```

- We are going to create helper method `renderAdmin`. So we do not have to put a ton of checking logic for our userId inside of `renderList` function. 
- Whenever `renderAdmin` function gets called, we are going to pass in the stream that we are currently iterating over. 
```js
renderAdmin(stream) {
    if (stream.userId === this.props.currentUserId) {
      return (
        <div className="right floated content">
          <button className="ui button primary">EDIT</button>
          <button className="ui button negative">DELETE</button>
        </div>
      );
    }
  }

  renderList() {
    return this.props.streams.map(stream => {
      return (
        <div className="item" key={stream.id}>
          {this.renderAdmin(stream)}
          <i className="large middle aligned icon camera" />
          <div className="content">
            {stream.title}
            <div className="description">{stream.description}</div>
          </div>
        </div>
      );
    });
  }
```
- Once we sign out, we are not going to see any button anymore.
- Now, we need to make sure that at the bottom of the page, whenever user is logged in, we show the button to allow a user to create a stream. 

## 126. Linking to Stream Creation

- We need to make sure that if the user is logged in, we show a button at the very bottom that says `Create Stream`.
- So if a user clicks on the button, it should be taken to a page where a user can create a new stream.
- Create a helper method `renderCreate` that renders a create button.
- Remember that we only want to show this button if the user is signed in.
- We already have some information about the current signIn status of the user inside the prop's object of our component. In the form of `currentUserId`.
- Whenever the user is not signed in, `currentUserId` is set to null.
- But we are not going to use the `currentUserId` for it.
- Because we actually have a property inside of our state object already. That is meant to be used anytime that we want to check to see if a user is sigend in or not signed in.
- And that is the `isSignedIn` property
- Now in order to get that `isSignedIn` property into `StreamList` component, we have to add it to our `mapStateToProps` function.
```js
const mapStateToProps = state => {
  return {
    streams: Object.values(state.streams),
    currentUserId: state.auth.userId,
    isSignedIn: state.auth.isSignedIn
  };
};
```
- When `Create Stream` button is clicked, a new page will be rendered. Therfore we are going to import `Link` in react-router-dom to use it.  
```js
import {Link} from 'react-router-dom'
renderCreate() {
    if (this.props.isSignedIn) {
      return (
        <div style={{ textAlign: "right" }}>
          <Link to="/streams/new" className="ui button primary">
            Create Stream
          </Link>
        </div>
      );
    }
  }

  render() {
    return (
      <div>
        <h2>Streams</h2>
        <div className="ui celled list">{this.renderList()}</div>
        {this.renderCreate()}
      </div>
    );
  }
}
```

## 127. When to Navigate Users

- Even though, a user successfully creates a stream, there is nothing on the screen. 
- We should automatically navigate the user back over to our list of streams after we have successfully created the stream. 
- Intentional Navigation
  - User clicks on a `Link` componenet.
- Programmatic Navigation
  - We run code to forcibly navigate the user through our app.
- We are going to use `Programmatic Navigation` to navigate the user.
- But we have to think about when exactly we want to navigate the user.
- Bad Approach
  - User submits the form
  - We make request to backend API to create stream
  - We navigate user back to the list of streams
  - (Time passes...)
  - API responds with error, stream was not created and user doesn't know!
- Good Approach
  - User submits the form
  - We make request to backend API to create the stream
  - (Time passes...)
  - API responds with success or error
  - We either show error to the user or navigate them back to list of streams.
- We only want to trigger navigation from our `createStream` action creator after we get a successful response back from our API.
- It might be a little bit more ideal to do the navigation after we dispatch the action.
```js
export const createStream = formValues => {
  return async (dispatch, getState) => {
    const { userId } = getState().auth;
    const res = await streams.post("/streams", { ...formValues, userId });

    dispatch({ type: CREATE_STREAM, payload: res.data });
    // Do some programmatic navigation to get the user back to the root route
  };
};
```

## 128. History References

- The good news is that programmatic navigation sometimes with react router dom is really easy but sometimes it is not easy at all.
- But we are in on scenarios where it is not easy to do programmatic navigation.
- Remember that we have a `BrowserRouter` at the very top of our component hierarchy, internally `BrowserRouter` creates `history` object. Anytime that address changes, the `history` object is going to communicate the change over to the `BrowserRouter`.
- But `history` object is not only about watching the address bar. It also has the ability to change the address bar as well.
- And that is how we are going to do programmatic navigation.
- However it is kind of challenging for us to write code that can get a handle of a reference to that history object. 
- Normal Operation in React router
  - Internally the `BrowserRouter` creates the `history` object then anytime that the `BrowserRouter` renders some component, `BrowserRouter` passes that `history` object as a prop down to the component.
  - So inside of any component that gets rendered directly by react router, it is going to receive the `history` object. So the component could very easily trigger some navigation inside of it. 
- But in our case, we are not trying to do navigation from a component, we are trying to do navigation from an action creator. 
- *Getting access to the `history` object inside of an action creator or any none react component* is what is a little bit challenging. 
- It is hard to get a reference to that `history` object. 
- So the solution would be to do something like this.
  - So we have got `history` object that gets created by the `BrowserRouter`, it communicates the `history` object down to our component and then we could say that anytime that our component calls our action creator, the component should pass along the `history` object into the action creator. 
- So essentially saying that inside of our action creator, we would receive not only our `formvalues` but also some `history` object as well.
```js
export const createStream = (formValues, history) => {
  return async (dispatch, getState) => {
    const { userId } = getState().auth;
    const res = await streams.post("/streams", { ...formValues, userId });

    dispatch({ type: CREATE_STREAM, payload: res.data });
    // Do some programmatic navigation to get the user back to the root route
  };
};
```
- Now this is kind of a pain because it means that every single time we want to do programmatic navigation, we would have to write our action creators to be called with a `history` object and we would make sure that all of our components called the action creator with the `history` object as well. 
- So even though this is possible but not super ideal. 
- We are going to use alternative solution.
- Remember that the `BrowserRouter` internally creates the `history` object and the fact that the `BrowserRouter` maintains that `history` object is what makes it challenging. 
- We are going to create a `history` object instead.
- So we are going to create a `history` object inside of a dedicated file inside of our project. Then anytime that we want to get access to that `history` object, we are just going to import that file very easily because we are maintaining control over the `history` object ourselves and we are not allowing react router to create the history object itself. 
- When we create `history` object, we are going to create a `history` object that is the corresponding type to whatever router we had created. 
- We are creating our own history object, we are no longer going to create a `BrowserRouter` object as the top of our component hierarchy.
- Instead we are going to create a `Plain Router`.
- We create `Plain Router` when we create the `history` object ourselves. 
- Programmatic navigation을 할때에는 `history` 객체를 사용해야한다.
- 하지만 기존의 `BrowserRouter`에 내장되어있는 `history` 객체에 접근하는게 번거롭다.
- 그러므로 `history` 객체를 따로 만들어주고 그 객체를 쓰기 위해 `BrowserRouter`가 아닌 `Router`를 쓰겠다는것.

## 129. Creating a Browser History Object

- Create new file history.js in src folder.
- We are going to create a `history` object and export it for use throughout our entire application.
- So the idea is that we maintain the `history` obejct as opposed to react router. 
- Because we are creating it, it is going to be a lot easier to get access to it and change what page the user is looking at. 
- So at the top of the file, import `createHistory`.
```js
import createHistory from "history/createBrowserHistory";
```
- History package was installed automatically with react router dom. 
- `createHistory` is a function that we can call to create a new `history` object. 
- And export it
```js
export default createHistory();
```
- After that, we are going to create `Plain Router` instead of `BrowserRouter`.
- If you pass custom `history` object to `BrowserRouter` in App component after import `history` object from history.js file, 
```js
import history from "../history";
<BrowserRouter history = {history}>
- (Anytime that we pass in a prop called `history`, the router is going to attempt to use it instead of default `history` object.)
- You will get an error inside of console saying
  ```js 
  Warning: <BrowserRouter> ignores the history prop.
  ```
- Therefore we need to import a `Plain Router` and we will pass our `history` object into that router. 
- To do so, instead of `BrowserRouter`, we are going to import just `Router`. And replace `BrowserRouter` tag to `Router` tag.
  ```js
  import { Router, Route } from "react-router-dom";
  <Router history={history}>
    <div>
      <Header />
      <Route path="/" exact component={StreamList} />
      <Route path="/streams/new" component={StreamCreate} />
      <Route path="/streams/edit" component={StreamEdit} />
      <Route path="/streams/delete" component={StreamDelete} />
      <Route path="/streams/show" component={StreamShow} />
    </div>
  </Router>
  ```
- You will not see any error inside of console and if you start to click around, the navigation occurs exactly as it did before. 
- So the only change is that we are now in charge of that `history` object as opposed to react router dom created internally.
- Now we have got the `history` object which means we can trigger direct navigation or programmatic navigation from our `createStream` action creator.


## 130. Implementing Programmatic Navigation

- We can import `history` into our action creator file and use it to automatically navigate our user around the application.
  ```js
    export const createStream = formValues => {
    return async (dispatch, getState) => {
      const { userId } = getState().auth;
      const res = await streams.post("/streams", { ...formValues, userId });

      dispatch({ type: CREATE_STREAM, payload: res.data });
      history.push('/')
    };
  };
  ```
## 131. Manually Changing API Records

- How you can clean up and manually manipulate some of the different streams that get created when you are using JSON server API.
- Using terminal, go inside the folder that `db.json` file is in.
- `db.json` holds all data inside of our application.
- Inside of the file, it contains all the different records we have created. 
- So if you want to make any changes manually the data inside of the application, you can just change the file.  

## 132. URL-Based Selection

- Anytime a user comes to EditStream page, we are going to allow them the opportunity to edit the title or the description of already created stream.
- We are going to talk about how a user can get to the page and how we are going to figure out what stream a user is trying to edit. 
- We need to communicate which edit button the user clicked over index page to edit page. 
- Option no.1
  - Selection Reducer
  - When a user clicks on a stream to edit it, use a 'selectionReducer' to record what stream is being edited. 
- Option no.2
  - URL-based selection
  - Put the ID of the stream being edited in the URL
  - We are going to essentially make sure that whenever a user clicks on the 'Edit' button, they will go to some address or some path that has the ID of the stream that they are trying to edit inside of the address bar.
- Anytime that you see colon and then some label inside the path that essentially means it has a variable.
  ex. `/streams/edit/:id`
- So because we can put the idea of the record that the user is trying to edit inside the URL, we can make use of react router dom to look at the URL and pull off just that portion of the URL. 
- Suppose in `/streams/edit/17`, then we can take that 17 and pass it as a prop into the `StreamEdit` component. 
- Then `StreamEdit` component will know that it needs to show the stream 17 and allow a user to edit specifically the stream with ID 17. 

## 133. Wildcard Navigation

- There are two seperate things to do
- First off we need to make sure that anytime that a user clicks on Edit button, they go to a route of something like `streams/edit` and then the ID of the stream that the user just clicked on the button for. 
- After that we need to make sure that we also update our routing information inside of our App.js file to make sure that anytime that a user goes to a URL like `streams/edits/:id`, it shows the `StreamEdit` component. 
- At present, we have wired up our routing rules to say that anytime a user goes to `stream/edit`, they see the StreamEdit component. So we are going to do a little tweak around our routing rules. 
- We are going to change Edit button to `Link`.
- But in this case we are not going to use fixed value in `Link to`. Instead we need to essentially take the idea of the stream and insert it into the `Link to` string we generate. 
  ```js
  renderAdmin(stream) {
    if (stream.userId === this.props.currentUserId) {
      return (
        <div className="right floated content">
          <Link to={`/streams/edit/${stream.id}`} className="ui button primary">
            Edit
          </Link>
          <button className="ui button negative">DELETE</button>
        </div>
      );
    }
  }
  ```
- If we click on one of buttons that we want to go to the StreamEdit component or that page, the information in the URL is trying to convey that we want to edit the stream with an ID of that page.  
- So now the next thing we need to do is make sure that we update our routing rules inside of App.js file. 
- We need to make sure that `Route path` understands that if a user ever goes to streams at it and then some ID, we still want to show `StreamEdit`.
- To do so, we are going to put on another forward `/` at the very end, add `:id`.
  ```js
   <Route path="/streams/edit/:id" component={StreamEdit} />
  ```
- So now if a user goes to `streams/edit/` anything, we are going to show the StreamEdit component. 
- For a quick note, as soon as puts `:`, anything inside of URL, that means this is going to be essentially a variable and it could have any value that you want for that part of the URL. 
- The colon(`:`) is what turns anything into a variable sorts.
- Next thing we need to do is to make sure that anytime that a user comes to `StreamEdit` page, we somehow get that number out of the URL and we communicate that number down into `StreamEdit`. So That StreamEdit component knows exactly what stream it is trying to change. 

## 134. More on Route Params

- We now need to make sure that we somehow get that little piece of information out of the URL and communicate it down to StreamEdit.
- We are going to add it on a reference to the props argument that this thing recieves and then I am going console.log it.
- We can check that there are 4 properties inside of props (history, location, match, staticContext).
- All the props that you see are coming from react-dom. 
- We only have access to these props specifically because the `StreamEdit` component inside of the file is being rendered by a route component. 
- Because `StreamEdit` is being rendered by route, react router dom automatically is going to add in a bunch of different props to `StreamEdit`.
- We can find the ID value inside of `params` in `match` props.
- Also we can put addition params inside of it
  ```js
  <Route path="/streams/edit/:id/:anotherId" component={StreamEdit} />
  ```
- Now we know exact ID of the stream that we are trying to edit, anytime that we click on the `Edit` button.
- Next thing, I want to try to load up some information about that particular stream and show it on the screen. Because eventually we want to allow a user to edit the information.
- But whenever we go to the StreamEdit page, we want to show the existing title and the existing description of the stream as it currently is. 

## 135. Selecting Records from State

- This time, we are going to try to print up some information about the stream that the user is trying to access from our `StreamEdit` component.
- Let's make sure that we can load up the appropriate stream, so we know what default title and description we should put into two text inputs.
- First off we need to know the ID of the stream that the user is trying to see. We can find ID inside of `match -> params -> id`.
- Second we need to know about is the list of streams inside of a `redux state object`.  
- So essentially between the props object and the list of streams that we have inside of our state store, we can somehow select the stream with an ID then print up some information about it inside of our component. 
- We are going to use `connect` function to get a list of streams into the component. 
- We want to print up the title and description insdie of `StreamEdit`.
- The component has accessed to the props object and that props object is what knows about ID that we are trying to show. But the props obejct appears to only be accessible inside of the StreamEdit function.
- On the other hand, `mapStateToProps` function is what knows about the big list of streams that is entirely that entirely stored inside of our state object. 
- So one source of information is up there, and the other source of information is available down there.
- Therefore, we are going to use `ownProps` argument.
- Also remember that streams property is an object where the keys of that object are the IDs of all the streams that we have loaded up. Therefore, anytime we want to select a record out of that object by using an ID, all we have to do is use the bracket notation.
  ```js
    const mapStateToProps = (state, ownProps) => {
    return{stream: state.streams[ownProps.match.params.id]}
  }
  ```
- So this should select the appropriate stream out of the object that contains all of our streams inside of redux store, assign that to the stream property insdie this object and then return it from `mapStateToProps` fucntion.
- So finally stream property in `mapStateToProps` contains the stream that our user is trying to edit.
- But if we `console.log(props)` inside of `StreamEdit` component, we can find that stream property is undefined that means we did not successfully pull the appropriate stream out of our streams object. 
- However, when you navigate back to main index page, and come back to `StreamEdit` page, stream property appears correctly. 
- Is seems like when we first loaded up the page, we had no stream. But then when we started to navigate around a little bit, it seemed like the streams suddenly showed up.

## 136. Component Isolation with React Router

- Steps for navigation according to ID
  - User types in `/streams/edit/3` to address bar and hits enter 
  - User loads up out app
  - Redux state object is empty!
  - We try to select stream with id '3' from state
  - No streams were loaded, so we get undefined!
    - So this is what exactly going on here.
    - When we navigate directly to streams at 3, we have not loaded up any streams into our application. 
    - So we immediately see zero data inside of our store when we try to pull some data out of it, that does not exist, we get undefined value. 
  - We navigated to `/`
  - `StreamList` fetches all of our streams using `componentDidMount`, update Redux state.
  - We navigate back to `/streams/edit/3`
  - We select stream with id of 3
  - Data is now in redux store, so we see the appropriate stream. 
- So the big issue is that we are trying to make get access to some data that has not yet been loaded up into the application. 
- Big lesson here about react router is that anytime that you are using this kind of ID based selection out of the URL, we always have to obey this rule.
- *WITH REACT-ROUTER, EACH COMPONENT NEEDS TO BE DESIGNED TO WORK IN ISOLATION (FETCH ITS OWN DATA!)*
- We really cannot assume that any given component will get access to some data that might have been loaded up previously inside the application. 
- If a user navigates directly to streams at 3, there are no streams to select from. So our StreamEdit component needs to load up the appropriate stream. It needs to call the action creator to reach out to the API and fetch the stream with ID 3 so that it can then show it on the screen. 
- We need to make sure that every component is not going to have some dependency on a user visiting some other route inside of our application ahead of time.
- A user could bookmark and then come back directly to a URL of streams and that would completely bypass the StreamList component which means users are always going to come directly to a given route inside the application.  
- Therefore every route and every component shown by that route needs to fetch it own data and it cannot rely upon some other component fetching data ahead of time for it. 
- 아이디가 따로 배정된 StreamEdit 페이지에서 state.streams를 이용해 데이터를 가져올려고 했으나 우리가 원하는 데이터는 StreamList 컴포넌트의 componentDidMount를 통해서만 가져올수가 있다. 즉 componentDidMount가 있는 StreamList가 렌더링이 되지 않으면 stream 리스트를 가져오지 못하므로 StreamEdit 페이지만 렌더링이 된다면 state는 빈 객체가 되어버린다.(각각의 컴포넌트들은 독립적으로 작동되어져야한다!)

## 137. Fetching a Stream for Edit Stream

- Essentially anytime our `StreamEdit` component is mounted on the screen or rendered to the screen, we want to make sure we call `fetchStream` action creator with the ID of the stream that we want to fetch. 
- And make sure that pass the ID of stream we want to fetch. 
  ```js
    class StreamEdit extends React.Component {
    componentDidMount() {
      this.props.fetchStream(this.props.match.params.id);
    }
    render() {
      return <div>StreamEdit</div>;
    }
  }

  const mapStateToProps = (state, ownProps) => {
    return { stream: state.streams[ownProps.match.params.id] };
  };
  ```
- When you `console.log(props)`, two console.log appear on the console. In second console.log, stream is successfuly fetched and showing up inside of the component. So do not forget to use `if` statement when you want to load up the title of the stream.
  ```js
  render() {
    if (!this.props.stream) {
      return <div>Loading...</div>;
    }
    return <div>{this.props.stream.title}</div>;
  }
  ```
- We are going to use this pattern in `StreamDelete` component and `StreamShow` component because both streams need to load up appropriate stream in order to show some details about it on the screen. 

## 138. Real Code Reuse!

- We can start to think about putting together the actual edit stream form.
- When you compare two mockups (Create Stream page and Edit Stream page), they are really similar compare to each other. 
- Big differences are headers of two are different and create stream does not have any initial title and description. Whereas edit stream is going to put the current title, description into the input so that a user can change it. 
- And different action creator gets called when the user presses the submit button.
- We are going to create a total of three components between create and edit pages.
- We are going to have a `StreamCreate`, `StreamEdit` and `StreamForm`. 
- The vast majority of showing text inputs, handling changes, wiring up to redux form, all that kind of stuff is all going to be done inside of new `StreamForm` component.
- So all the logic that hooks up to redux form, all the logic that renders text inputs, all the logic that submits the form and handles the mission appropriately, we are going to place inside of `StreamForm` component.
- We are going to refactor `StreamCreate`, `StreamEdit` components and they are going to show internally the `StreamForm` component.
- We need to make sure that `StreamCreate` component passes down `onSubmit` callback to `StreamForm`.
- In addition, StreamEdit component passes down `onSubmit` callback and `initialValues`.
- Create StreamForm.js inside of src folder. 
- `StreamCreate` component already has a tremendous amount of logic inside of it for showing the form and the error messaging and all that kind of stuff. So we want to take all the logic inside of the component and refactor `StreamCreate` to make sure that it does not call any action creator when it gets submitted. Instead `StreamForm` should call some `callback` that gets passed down from a parent component. 
- Copy the code inside of `StreamCreate` component and gives some changes.
  - And it does not action creator. It is a parent component that calls some action creator.
  - `StreamForm` does not need connect function.
  - `StreamForm` should attempt to call a callback passed down from props from some parent component. So `onSubmit` function calls `this.props.onSubmit(formValues)`.
  ```js
  onSubmit = formValues => {
    this.props.onSubmit(formValues);
  };
  ```
  - So now we are going to expect the parent component to pass down a callback called `onSubmit`, and this is going to be called with whatever values are coming out of our form. 

## 139. Refactoring Stream Creation

- `StreamCreate` is no longer going to be showing a form. So we don't need a filed or redux form anymore. 
- We need to import `StreamForm` component. 
- We don't need to render an error and inputs anymore. 
- We are not going to show a form, Field and button anymore. So entire jsx inside of render method can be removed.
- And we will replace that with just enough to show the form and a header at the top.
- We can place our `StreamForm` component inside of render method and pass `onSubmit`. 
  ```js
    render() {
      return (
        <div>
          <h3>Create a Stream</h3>
          <StreamForm onSubmit={this.onSubmit} />
        </div>
      );
    }
  }
  ```
- We also do not need `validation` function because the validation is being handled by `StreamForm` component.
- And no wrapping `reduxForm` anymore.
- `StreamForm`이 `redux form` 라이브러리를 사용함
- `StreamForm` 컴포넌트의 form에 `handleSubmit`안에서 전달된 `onSubmit` 함수의 `formValues` 인수는 `redxu form`에 의해서 form의 input에 입력된 값을 가지게됨.
- 그 값을 부모 컴포넌트인 `StreamCreate`에서 props로 내려준 `onSubmit`에 넣어주게되면
- `StreamCreate` 컴포넌트의 `onSubmit` 함수는 받은 값으로 action creator를 실행함. 

## 140. Setting Initial Values

- We are going to do same thing for `StreamEdit` as well.
- `StreamEdit` is going to be very similar to the work we just did inside of `StreamCreate`, the only big difference is that we want to make sure that the form is going to show some initial values inside of those inputs. 
- How are we going to do that with redux form?
- So we have StreamEdit that is showing StreamForm wrapped inside of the `redux form` helper.
- Unlike we did for `StreamCreate` component, we are not actually passing props directly to our StreamForm component. 
- Instead we are technically passing props to `redux form`. It then turns around and passes those props onto `StreamForm` component. 
- So there are actually some very special props that we can pass down into the `redux form` that wrapped the component. 
- One special prop name is `initialValues`.
- `initialValues` contains title and description.
- If we pass some `initialValues` prop from `StreamEdit` down to `redux form` wrapped `StreamForm`, it is going to provide some initial values of title and description to show inside of the text inputs inside of `StreamForm`.
- This is a key topic for understanding how to set up any type of form with `redux form`.
- Inside of `StreamEdit` component, along with `fetchStream`, import `editStream` action creator as well. 
  ```js
  import { fetchStream, editStream } from "../../actions";
  ```
- `editStream` is what is going to eventually allow us to take the idea of a stream and some new properties for the stream and update our API record.
- and import `StreamForm` component as well.
  ```js
  import StreamForm from './StreamForm'
  ```
- In order to take the value of inputs that user edits, create `onSubmit` function.
  ```js
  onSubmit = (formValues) => {
    console.log(formValues)
  }
  ```
- In `render` method, just returning a title of the stream, we are going to instead return a multi-line block of jsx. 
  ```js
  return (
      <div>
        <h3>Edit a Stream</h3>
        // this is where we will specify our initial values. 
        <StreamForm onSubmit={this.onSubmit} />
      </div>
    );
  ```
- We still need `mapStateToProps` to get some initial value for the form. 
  ```js
    const mapStateToProps = (state, ownProps) => {
    return { stream: state.streams[ownProps.match.params.id] };
  };
  ```
- We still want to have the `connect` function, `fetchStream` action creator. So only the change is we pass `editStream`.
  ```js
    export default connect(
    mapStateToProps,
    { fetchStream, editStream }
  )(StreamEdit);
  ```
- In order to get initial values when a user edits the page, pass the props `initialValues` to `StreamForm` component.
- Remember that `initialValues` is a special prop.
- Since we are going to pass normal object through `initialValues` prop, we are going to use double curly braces.
  ```js
  return (
      <div>
        <h3>Edit a Stream</h3>
        <StreamForm
          initialValues={{ title: "EDIT ME", description: "CHANGE ME TOO" }}
          onSubmit={this.onSubmit}
        />
      </div>
    );
  ```
- Now we are passing `initialValues` down to a component that is wrapped by `redux form`, 
  ```js
  initialValues={{ title: "EDIT ME", description: "CHANGE ME TOO" }}
  ```
  this will be used as the initial values inside of the form itself.
- So `redux form` is going to use if that `initialValues` property has a property of title and a property of description. And if they do then those values will be used as the initial values for the `Field` inside of `StreamForm` component.
- Now we can check the initial values inside of the edit page. 
- Remember that `stream` is an object with a title and a description property. So now the title and description off of our `stream` object will be used as the `initialValues` for the the form. 
  ```js
  <StreamForm
    initialValues={this.props.stream}
    onSubmit={this.onSubmit}
  />
  ```
- If we change initial values inside of inputs and submit, it is going to trigger `onSubmit` callback we defined inside of `StreamEdit` and update values. 
- But there is a small issue here. 
  
## 141. Avoiding Changes to Properties

- The application works just fine as is but this issue that might get you in trouble when you start working on other project and it comes down to how ytour back-end server is set up.
- When you console.log your change, we will find out that there are some other properties are inside of the object beside of title and description(ID and userId). 
- When we eventually call `onSubmit` callback in side of `StreamEdit`, we are getting some object that contains *what are supposed to be updates to our stream object*. In order words `formValues` is only supposed to contain properties that are supposed to change on our form.
- And telling API that here are some change properties which are title and description that you should use to update some given `stream`.
- The issue with this is that when we pass the ID or userID, it kind of makes it seems as though we have changed the ID or userId. 
- Therefore we want to trim down the properties inside of the object.
- We put entire object of `stream` inside of `initialValues` and that causes the issue. 
- We are going to use `lodash` to solve it. 
  ```js
  <StreamForm
    initialValues={_.pick(this.props.stream, "title", "description")}
    onSubmit={this.onSubmit}
  />
  ```
- Example of `pick` function in `lodash`
  ```js
    const profile = {
    name: 'Sam',
    age: 18,
    favoriteColor: 'green'
  }
  _.pick(profie, 'name', 'age') // {"name" : "Sam", "age":18}
  ```

## 142. Edit Form Submission

- Whenever `onSubmit` inside of `StreamEdit` component gets called with `formValues` object, we need to call some appropriate action creator.  
- Inside of `onSubmit`, we really have to do it call action creator.
- In `editStream` action creator, `formValues` is supposed to be the changed properties of the `stream` and it contains only title and description. 
  ```js
  onSubmit = formValues => {
    this.props.editStream(this.props.match.params.id, formValues);
  };
  ```
- And do not forget to use custom `history` to navigate a user after complete the change. 
  ```js
    export const editStream = (id, formValues) => {
    return async dispatch => {
      const res = await streams.put(`streams/${id}`, formValues);

      dispatch({ type: EDIT_STREAM, payload: res.data });
      history.push('/')
    };
  };
  ```
- But when we edit a stream, you will find out that we have lost edit and delete buttons as well!

## 143. PUT vs PATCH Requests

- When we check the Response tab in Network tab in developer console, we do not find the ID of stream that we just editted.
- Actually `PUT` request has a little side effect to it. That is very commonly not well implemented in a lot of back-end API. 
- When you make a `PUT` request, the actual thing that happens is whatever properties you put inside the body of that request are going to replace all the properties inside of the record that you are trying to update. 
- In other words when we just made our update request were `PUT` requests, on submission that form, we posted the title and description property. 
- The problem is that when we made `PUT` request to our API, the API said 'I see a title and description and I see you made a `PUT` request so I am going to take all the different properties inside the stream, the title, ID, description and userId as well. And I am going to replace them with just the properties that you posted to the API.'
- *But remember that the one property that is usually immune to this is the ID property*
- As you know we did not update our userId but our back-end API interpreted that 'you no longer want a userId' and so it just dropped of userId entirely.
- This is the reason why buttons are not showed up. 
- In orther words, `PUT` request is going to replace or update all properties of a record which could potentially lead to deleting properties off a record on the API.
- If we really want to just update some properties, we are actually supposed to use a different type of request called a `PATCH` request so that the `PATCH` request, we are going to pass some properties inside of the body the request that are supposed to be updated on the API. And with the request, just those properties are going to be updated. 
  ```js
    export const editStream = (id, formValues) => {
    return async dispatch => {
      const res = await streams.patch(`streams/${id}`, formValues);

      dispatch({ type: EDIT_STREAM, payload: res.data });
      history.push("/");
    };
  };
  ```

## 144. Why Use Portal?

- This time we are going to build a modal window to the user that is going to force user to either delete a steram or not delete a stream.
- But showing modal using react is bit challenging.
- Any react application, all of our elements are nested inside of `div` with  ID or `root` and that is the normal operation of react. 
- However there is a feature inside of react called `portal`. 
- We are going to ultimately use a `portal` to kind of get around the requirement of having to nest all of our different components elements whatever you want to call it inside of `div` with ID of root. 
- We are going to make a normal HTML document and we are going to try to get a little modal window to show up inside of it. And as we go though the process, you are going to realize that using typical react to do this might be little challenging.
- Create modal.html file inside of public folder. 
  ```html
  <head>
  <style>
    .sidebar {
      position: fixed;
      top: 0;
      left: 0;
      height: 100vh;
      width: 300px;
      background: green;
    }
    .content {
      margin-left: 300px;
    }
  </style>
</head>
<body>
  <div class="modal">
    <div class="modal-body"><h1>I am a modal</h1></div>
  </div>
  <div class="sidebar">I am a sidebar</div>
  <div class="content"><h1>I am some content</h1></div>
</body>
  ```
- You can check the text here : 'http://localhost:3000/modal.html

## 145. More on Using Portals

- We set HTML document like this below:
  ```html
    <head>
    <style>
      .sidebar {
        position: fixed;
        top: 0;
        left: 0;
        height: 100vh;
        width: 300px;
        background-color: green;
      }
      .content {
        margin-left: 300px;
      }
      .modal-body {
        background-color: white;
        margin: auto;
        height: 30%;
        width: 30%;
      }
      .modal {
        height: 100%;
        width: 100%;
        position: fixed;
        background-color: grey;
        left: 0;
        top: 0;
      }
    </style>
  </head>
  <body>
    <div class="modal">
      <div class="modal-body"><h1>I am a modal</h1></div>
    </div>
    <div class="sidebar">I am a sidebar</div>
    <div class="content"><h1>I am some content</h1></div>
  </body>
  ```
- But we can still see that sidebar 'I am a sidebar`.
- The sidebar should not be displayed on top of the modal. 
- We can fix this issue using `z-index`.
  ```css
  .modal {
      height: 100%;
      width: 100%;
      position: fixed;
      background-color: grey;
      left: 0;
      top: 0;
      z-index: 10;
    }
  ```
- But here is the problem. When we show a content of react, we are always showing all of our components inside of a single `div`.
- So remember that `Modal` is always going to be deeply nested inside of our application. We might have a tremendous amount of HTML or jsx with a ton of styling as parents to the `Modal` component. 
- Some assigned value of `z-index` creates something called a `stacking context`.
- When we create `stacking context`, it essentially creates a new way of comparing different sibling elements that have assigned `z-index` values that might want to be rendered on top of each other.
- Essentially when we create stacking context, we no longer compare sidebar's `z-index` with a `Modal`'s `z-index`.
- Instead we compare sidebar's z-index with the root element that has the `stacking context` that contains `Modal`.
- Someday you might work on an application that already has hundreds of components inside of it and you might have a super deeply nested component structure. So it is not always going to be quite so easy for us. 
- So it is not always a good solution to delete `div` or to change the `z-index`. 
- It is highly likely that if you are adding a modal into some existing application, you might end up having to break the entire layout and rewrite all the CSS for the project. 
- Here is what we are going to do:
  - Rather than showing our modal as a child of positioned, we are going to instead show the modal as a child of the body. 
  - This essentially saying rather than follow the normal rules of react where we nest all of our components underneath each other, we should try to kind of break or bend this rule a little bit and that is exactly what we are going to do by using this portal.
  - With portal, we do not have to stick with typical react component hierarchy where everything is a child of `div` with ID of root. 
  - Instead when we use a portal, we can essentially say 'Ok StreamDelete we want you to render a modal component but we don't want to have you render a modal as a direct child. Instead try to render the `Modal` component but make it a child of some other element in our HTML hierarchy such as body element. 
  - So this is the purpose of `portal`.
  - It allows us to render some element not as a direct child. We can instead render that element or that component as a child of some other element inside our HTML structure most commonly the body. 

## 146. Creating a Portal

- Create a new file Modal.js inside of components folder.
- When we create portal, return value changes a little bit.
  ```js
  import React from "react";
  import ReactDOM from "react-dom";

  const Modal = props => {
    return ReactDOM.createPotal(
      <div className="ui dimmer modals visible active">
        <div className="ui standard modal visible active">sadfasdfasdfasdfsvdfsf</div>
      </div>
    );
  };

  export default Modal;
  ```
- Two `div`s rendered directly on our body element as opposed to being deeply nested underneath like `StreamDelete`. 
- After we attach `Modal` appropriately to the body element, we are going to provide a second argument to create a portal. 
- If we try to attach `Modal` to the body or give a direct reference to the body then that portal is going to actually replace all the current content in the body. 
- So instead what we usually do when we create a portal is we will go into our index.html file and we will create a new `div` with some ID and we will target that `div` to place our modal into. 
- So create new tag right below root in index.html
  ```html
  <div id="root"></div>
  <div id="modal"></div>
  ```
- And now we are going to provide a reference to id modal to create portal call. 
  ```js
    const Modal = props => {
    return ReactDOM.createPortal(
      <div className="ui dimmer modals visible active">
        <div className="ui standard modal visible active">sadfasdfasdfasdf</div>
      </div>,
      document.querySelector("#modal")
    );
  };
  ```
- So `Modal` component will be rendered into `div` with an ID of modal.
- Place `Modal` component inside of `StreamDelete` component.
  ```js
    const StreamDelete = () => {
    return (
      <div>
        StreamDelete
        <Modal />
      </div>
    );
  };

  export default StreamDelete;
  ```
- Anytime that we show `StreamDelete`, we are going to render `Modal`.
- It is going to take the jsx and attempt to insert it as a child to `div` with the ID of modal. 
- Now we can find `Modal` appears on the screen successfully.

## 147. Hiding a Modal

- We are going to use semantic-ui to style `Modal`.
  ```js
   <div className="header">Delete Stream</div>
    <div className="content">
      Are you sure you want to delete this stream?
    </div>
    <div className="actions">
      <button className="ui primary button">Delete</button>
      <button className="ui button">Cancel</button>
    </div>
  ```
- Modal looks way better than before but when we click outside of modal, the modal is not dismissed. Let's figure out how to do it. 
- So essentially if a user clicks on the background, we want to navigate the user to some other location or path inside of our app. 
- We can get a user to navigate programmatically by making use of that `history` object that we created a little bit ago.
- So import history from the history.js and set push in `div`
  ```js
  <div
    onClick={() => history.push("/")}
    className="ui dimmer modals visible active"
  >
  ```
- However, it also works when we click the inside of popup box right next to buttons.
- Because this is very basic event handling. This is event propagation. 
- It is default JS, HTML behavior.
- If we ever trigger an event on some child elements and that child element does not handle the event. 
- The event is going to essentially bubble up to some parent element until it eventually gets caught with an event handler.
- So if we click on any of the elements inside of `div` tag that has `className='ui dimmer modals visible active'`, the event handler is going to run the onClick event inside of that `div` tag which is going to run `history.push('/')`. 
- In order to prevent event propagation, we can add a click event handler to `div className='ui standard modal visible active'`. 
  ```js
  <div
    onClick={e => e.stopPropagation()}
    className="ui standard modal visible active"
  >
  ```
- `stopPropagation` is going to make sure that the event does not continue to bubble up and go to parent `div` does causing our window to get dismissed by navigating to some other page. 
- But modal might be used in many other locations insdie of the application where we want to show a modal and in everyone of those cases, we probably are going to want to have a different header and different content, different buttons and different things to occur whenever user clicks those buttons and back to different location expected by users.

## 148. Making the Modal Reusable

- We have hard coded text and button and route inside of `Modal` component but highly likely we are going to use this component other side of the component. 
- We should configure the modal based upon some props that get passed into it from the parent component. 
- That will make our `Modal` much more reusable if we ever want to use it again in the future. 
- We are going to pass some couple of props that will be used to customize how the modal looks and behaves. 
  ```js
    const actions = (
      <div>
        <button className="ui button negative">Delete</button>
        <button className="ui button">Cancel</button>
      </div>
    );
    return (
      <div>
        StreamDelete
        <Modal
          title="Delete Stream"
          content="Are you sure you want to delete this stream?"
          actions={actions}
        />
      </div>
    );

    const Modal = props => {
    return ReactDOM.createPortal(
      <div
        onClick={() => history.push("/")}
        className="ui dimmer modals visible active"
      >
        <div
          onClick={e => e.stopPropagation()}
          className="ui standard modal visible active"
        >
          <div className="header">{props.title}</div>
          <div className="content">{props.content}</div>
          <div className="actions">{props.actions}</div>
        </div>
      </div>,
      document.querySelector("#modal")
    );
  };
  ```

## 149. React Fragments

- We are going to use `React.Fragment`.
- It is jsx looking element that is going to allow us to return assigned multiple elements to a single variable. 
- But when it gets rendered onto the screen, it does not actuallyt produce any HTML. 
- So you can think of `React.Fragment` as being like an invisible element that does not have any impact on dom whatsoever. 
  ```js
  <React.Fragment>
    <button className="ui buttonnegative">Delete</button>
    <button className="uibutton">Cancel</button>
  </React.Fragment>
  ```
- `React.Fragment` did not render anything into the DOM whatsoever. 
- You can shorten `React.Fragment` as <></>.
- But some code checker might think that <></> syntax is not valid. 

## 150. OnDismiss From the Parent

- `onClick` function inside of `div`, will always navigate user to the root route of the application. 
- It is possible if we use a modal somewhere else that we will not want to take the user to the root route if they attempt to dismiss it. 
- We might want to do some other behavior maybe try to dismiss the modal by some means. 
- So `onClick` function should be provided by the parent component. 
- Remove `() => history.push("/")`, we are going to call `props.onDismiss`, this is new prop that we need to add in from the parent component. 
- In order to make `history` object inside of `StreamDelete` component, import the object and pass it down to `Modal` component. 
  ```js
  <Modal
    title="Delete Stream"
    content="Are you sure you want tdelete this stream?"
    actions={actions}
    onDismiss={() => history.push("/")}
  />
  ```
## 151. Reminder on Path Params

- When we click on that Delete button, we actually attempt to delete the stream. And we click on Cancel, we have to make sure we dismiss the modal.
- And it would be really helpful if the user understood what stream they were trying to delete. 
- So it would be really nice if maybe inside of content, we printed out the title of the stream that the user was about to delete. 
- So in order to show the title of a given stream we need to make sure that we have first loaded it up into the application. 
- We need to first fetch the stream with idea of ID before we could show its title and description inside of the form.
- And make sure that we reflect the ID of the stream that the user is trying to delete inside of URL. 
- We are going to make sure that we attempt to fetch that stream from our API and then we are going to get the stream into our component so we can print the title of it inside of the modal itself.
- So instead of when a user goes to `stream/delete`, we want to show to modal when a user goes to `stream/delte/id`.
- First thing we need to do is make sure that we update the route that a user can go to and show that particular stream.
- So go to App.js file and change the route of `steams/delete` to `streams/delete/:id`.
  ```js
  <Route path="/streams/delete/:id" component={StreamDelete} />
  ```
- Next thing we are going to do is make sure that anytime a user clicks on Delete button, we navigate to the appropriate URL to attempt to delete that very particular stream.  
- Inside of `renderAdmin` function in `StreamList` component, at present it is showing simple button element. 
  ```js
   <div className="right floated content">
      <Link to={`/streams/edit/${stream.id}`className="ui button primary">
        Edit
      </Link>
      <button className="ui buttonegative">DELETE</button>
    </div>
  ```
- Rather than having a button element, I want to instead show a `Link` element that a user can click on to navigate over to the `StreamDelete` page. 
  ```js
  div className="right floated content">
    <Link to={`/streams/edit/${stream.id`} className="ui button primary">
      Edit
    </Link>
    <Link to={`/streams/delete/{stream.id}`} className="ui buttnegative">DELETE</Link>
  </div>
  ```
- If we look at the URL at the top, we should see streams delete and then the ID of stream that I am trying to delete. 

## 152. Fetching the Deleting Stream

- Now we need to start to refactor the StreamDelete component. 
- We are going to turn it into a class based component and we are going to make sure that anytime it gets rendered to the screen, it attempts to fetch the stream with the ID.
- So we can show the title of it inside the body or content area of the modal. 
  ```js
    class StreamDelete extends React.Component {
    renderActions() {
      return (
        <React.Fragment>
          <button className="ui button negative">Delete</button>
          <button className="ui button">Cancel</button>
        </React.Fragment>
      );
    }

    render() {
      return (
        <div>
          StreamDelete
          <Modal
            title="Delete Stream"
            content="Are you sure you want to delete this stream?"
            actions={this.renderActions()}
            onDismiss={() => history.push("/")}
          />
        </div>
      );
    }
  }
  ```
- We can now add in a lifecycle method that will attempt to call the action creator to go and fetch the stream that we are trying to delete. 
- Remember that we have to make sure that every component that gets rendered by react dom attempts to fetch its own data. 
- Wire up action creator and lifecycle method inside of `StreamDelete` component to get a data inside of the component. 
  ```js
  componentDidMount() {
    this.props.fetchStream(this.props.match.params.id);
  }
  ```

## 153. Conditionally Showing Stream Details

- Actually deleting as usual to get some information from our redux store into our component, we are going to use `mapStateToProps` function.
  ```js
    const mapStateToProps = (state, ownProps) => {
    return {
      stream: state.streams[ownProps.match.params.id]
    }
  }
  ```
- Quick reminder when the component first gets rendered to the screen, it is entirely possible that we will not have our stream loaded up just yet.
- Remember the component is going to be rendered to the screen one time then our `componentDidMount` lifecycle method will be called. 
- But before the lifecycle gets render, it would be better if we showed the modal right away and maybe we just do not have the text for the stream that is supposed to be displayed.
- So the user will see a modal right away and then like a half second later, the title of the stream will appear inside of the content. 
  ```js
  renderContent() {
    if (!this.props.stream) {
      return "Are you sure you want to delete this stream?";
    }

    return `Are you sure you want to delete the stream with title : ${
      this.props.stream.title
    }`;
  }
  render() {
    return (
      <Modal
        title="Delete Stream"
        content={this.renderContent()}
        actions={this.renderActions()}
        onDismiss={() => history.push("/")}
      />
    );
  }
  ```

## 154. Deleting a Stream

- The last thing we have to do with our StreamDelete modal is make sure that two buttons actually do something. 
- So if a user clicks on Cancel button, we probably want to just take the user back to the stream list page. 
- We can just turn Cancel button into react router dom link tag instead. 
  ```js
  <React.Fragment>
    <button className="ui button negative">Delete</button>
    <Link to="/" className="button">
      Cancel
    </Link>
  </React.Fragment>
  ```
- And when a user clicks Delete button, that is going to attempt to reach out to our API and delete that very particular stream. 
- Whenever we want to delete a stream, we just need to pass the ID of the stream that we want to do it. And also after we click the button, the user should navigate back to main page. 
  ```js
    export const deleteStream = id => {
    return async dispatch => {
      await streams.delete(`streams/${id}`);

      dispatch({ type: DELETE_STREAM, payload: id });
      history.push("/");
    };
  };
  ```
- Import `deleteStream` action creator to `StreamDelete` component and wire it up. 
  ```js
   <button
      onClick={() =this.props.deleteStre(this.props.match.params.id)}
      className="ui button negative"
    >
  ```
- When delete request is successful, we are going to get empty object inside of preview tab in network tab.

## 155. Viewing a Stream

- We are going to create StreamShow page. 
- We are going to first focus on just making sure that we can load up particular stream and show some details about it on the page.
- The entire process is going to be just about identical to what we have now gone through with edits and delete.
- We are going to want to make a class based component and that is going to attempt to look at the URL, find the ID inside there, fetch that stream, get the stream out of our redux store and then show it inside the render method. 
- In App.js folder, change the URL of StreamShow component.
  ```js
  <Route path="/streams/:id" component={StreamShow} />
  ```
- We are going to wrape `stream.title` inside of `renderList` method in `StreamList`.
- So whenever a user clicks on the title, we attempt to navigate the user over to the appropriate page. 
  ```js
  <Link to={`/streams/${stream.id}`} className="header">
    {stream.title}
  </Link>
  ```

## 156. Switcheds with React-Router

- After we click a one of stream in the list and then click `Create Stream` button, we can see very strange behavior.
- The word `StreamShow` appears under `Submit` button.
- So it appears when we go to `stream/new`, we see bothe `StreamCreate` component and `StreamShow` component at the same time. 
- Reminds that when we first started talking about react-router-dom, we spoke about how react router tries to match different paths greedily. 
- In order words, if a given path mathes a route, the route will be shown no matter what react router dom does not try to just show one route, it is going to show every single route that matches the given path. 
- With that in mind, see both routes.
  ```js
    <Route path="/streams/new" component={StreamCreate} />
    <Route path="/streams/:id" component={StreamShow} />
  ```
- `:id` is essentially a vairiable. It does not only match variables that are numbers, it will match anything in that part of th URL.
- So when we go to `streams/new` is essentially taking the text `new` because it thinks `new` is like a variable or a idea of sorts.
- That is why we see both `StreamCreate` and `StreamShow`.
- Therefore we need to figure out some way to only show one component. 
- In order to do so we are going to import another helper component from react-router-dom.
  ```js
  import { Router, Route, Switch } from "react-router-dom";
  ```
- So `Switch` is going to look at all different routes and it is only going to show one of these given routes for any path that we go to. 
  ```js
  <Switch>
    <Route path="/" exact component={StreamList} />
    <Route path="/streams/new" component={StreamCreate} />
    <Route path="/streams/edit/:id" component={StreamEdit} />
    <Route path="/streams/delete/:id" component={StreamDelete} />
    <Route path="/streams/:id" component={StreamShow} />
  </Switch>
  ```
- Now whenever we go to `stream/new`, this route will be shown and react-router-dom is going to think that I am not going to show any other potential route. 

## 157. Showing a Stream

- In `StreamShow` component, we need to read the ID out of the URL and we need to call the action creator to fetch that particular stream and then use a `mapStateToProps` function to get that stream out of our redux store and into our component. 
- We are going to user `fetchStream` ,`connect` function, `mapStateToProps` function.
  ```js
  import React from "react";
  import { connect } from "react-redux";
  import { fetchStream } from "../../actions";

  class StreamShow extends React.Component {
    componentDidMount() {
      this.props.fetchStream(this.props.match.params.id);
    }

    render() {
      if (!this.props.stream) {
        return <div>LOADING...</div>;
      }
      const { title, description } = this.props.stream;
      return (
        <div>
          <h1>{title}</h1>
          <h5>{description}</h5>
        </div>
      );
    }
  }

  const mapStateToProps = (state, ownProps) => {
    return { stream: state.streams[ownProps.match.params.id] };
  };

  export default connect(
    mapStateToProps,
    { fetchStream }
  )(StreamShow);

  ```

## 158. The Context System

- Props System
  - Gets data from a parent component to a direct child component.
- Context System
  - Gets data from a parent component to any nested child component. 

## 159. Getting Data Out of Context

- The context system is all about communication some information from a parent component down to a nested child.
- In translation app, parent component is the `App`. and the nested child that we want to communicate some information to is both `Button` and `Field` components in order to communicate the information. 
- In order to do that we are going to create Context Object.
- There are two ways that we can get infromation into a context object.
- And there are two ways that we can get information out or out of the pipe. 
- Inside of parent component, we can create something called a `Provider` component and this component can essentially push information into the context object. 
- This is how we get information into the Context object. 
- Once we get some information out of the object, inside of a nested child component, we can create a component called a `Consumer` component.
- This is how we get information out of the Context object. 








  



  

